// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

#include "ops_generated.h"

namespace mindspore {
namespace schema {

struct QuantParam;

struct Tensor;

struct Primitive;

struct CNode;

struct MetaGraph;

enum NodeType {
  NodeType_ValueNode = 0,
  NodeType_Parameter = 1,
  NodeType_CNode = 2,
  NodeType_MIN = NodeType_ValueNode,
  NodeType_MAX = NodeType_CNode
};

inline const NodeType (&EnumValuesNodeType())[3] {
  static const NodeType values[] = {
    NodeType_ValueNode,
    NodeType_Parameter,
    NodeType_CNode
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[] = {
    "ValueNode",
    "Parameter",
    "CNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (e < NodeType_ValueNode || e > NodeType_CNode) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum PrimitiveType {
  PrimitiveType_NONE = 0,
  PrimitiveType_Concat = 1,
  PrimitiveType_SoftMax = 2,
  PrimitiveType_Activation = 3,
  PrimitiveType_Conv2D = 4,
  PrimitiveType_FusedBatchNorm = 5,
  PrimitiveType_CaffeBatchNorm = 6,
  PrimitiveType_BiasAdd = 7,
  PrimitiveType_Pooling = 8,
  PrimitiveType_DepthwiseConv2D = 9,
  PrimitiveType_DeDepthwiseConv2D = 10,
  PrimitiveType_Resize = 11,
  PrimitiveType_DetectionPostProcess = 12,
  PrimitiveType_FullConnection = 13,
  PrimitiveType_Mean = 14,
  PrimitiveType_DeConv2D = 15,
  PrimitiveType_Scale = 16,
  PrimitiveType_Reshape = 17,
  PrimitiveType_Eltwise = 18,
  PrimitiveType_NetOutput = 19,
  PrimitiveType_Add = 20,
  PrimitiveType_Sub = 21,
  PrimitiveType_MatMul = 22,
  PrimitiveType_StridedSlice = 23,
  PrimitiveType_Power = 24,
  PrimitiveType_Slice = 25,
  PrimitiveType_Stack = 26,
  PrimitiveType_Mul = 27,
  PrimitiveType_RealDiv = 28,
  PrimitiveType_Pad = 29,
  PrimitiveType_Maximum = 30,
  PrimitiveType_Minimum = 31,
  PrimitiveType_CaffePReLU = 32,
  PrimitiveType_LeakyReLU = 33,
  PrimitiveType_ArgMax = 34,
  PrimitiveType_ArgMin = 35,
  PrimitiveType_Exp = 36,
  PrimitiveType_Crop = 37,
  PrimitiveType_Range = 38,
  PrimitiveType_Rsqrt = 39,
  PrimitiveType_ExpandDims = 40,
  PrimitiveType_Tile = 41,
  PrimitiveType_Cast = 42,
  PrimitiveType_Shape = 43,
  PrimitiveType_Nchw2Nhwc = 44,
  PrimitiveType_Nhwc2Nchw = 45,
  PrimitiveType_QuantDTypeCast = 46,
  PrimitiveType_Split = 47,
  PrimitiveType_Permute = 48,
  PrimitiveType_FakeQuantWithMinMaxVars = 49,
  PrimitiveType_Equal = 50,
  PrimitiveType_Less = 51,
  PrimitiveType_Greater = 52,
  PrimitiveType_NotEqual = 53,
  PrimitiveType_LessEqual = 54,
  PrimitiveType_GreaterEqual = 55,
  PrimitiveType_Min = 56,
  PrimitiveType_Floor = 57,
  PrimitiveType_Abs = 58,
  PrimitiveType_Neg = 59,
  PrimitiveType_Cos = 60,
  PrimitiveType_Sin = 61,
  PrimitiveType_Sqrt = 62,
  PrimitiveType_Square = 63,
  PrimitiveType_Constant = 64,
  PrimitiveType_Log = 65,
  PrimitiveType_Tan = 66,
  PrimitiveType_Atan = 67,
  PrimitiveType_Asin = 68,
  PrimitiveType_Clip = 69,
  PrimitiveType_Transpose = 70,
  PrimitiveType_Squeeze = 71,
  PrimitiveType_Unsqueeze = 72,
  PrimitiveType_Upsample = 73,
  PrimitiveType_Dropout = 74,
  PrimitiveType_Broadcast = 75,
  PrimitiveType_BroadcastTo = 76,
  PrimitiveType_Lrn = 77,
  PrimitiveType_Prelu = 78,
  PrimitiveType_ZerosLike = 79,
  PrimitiveType_TopK = 80,
  PrimitiveType_SpaceToDepth = 81,
  PrimitiveType_SpaceToBatch = 82,
  PrimitiveType_SparseToDense = 83,
  PrimitiveType_ReverseSequence = 84,
  PrimitiveType_Rank = 85,
  PrimitiveType_Gather = 86,
  PrimitiveType_GatherNd = 87,
  PrimitiveType_Fill = 88,
  PrimitiveType_Elu = 89,
  PrimitiveType_DepthToSpace = 90,
  PrimitiveType_BatchToSpace = 91,
  PrimitiveType_AddN = 92,
  PrimitiveType_Ceil = 93,
  PrimitiveType_EmbeddingLookup = 94,
  PrimitiveType_EmbeddingLookupSparse = 95,
  PrimitiveType_FloorDiv = 96,
  PrimitiveType_FloorMod = 97,
  PrimitiveType_L2Norm = 98,
  PrimitiveType_LocalResponseNormalization = 99,
  PrimitiveType_MatrixDiag = 100,
  PrimitiveType_Reduce = 101,
  PrimitiveType_Reverse = 102,
  PrimitiveType_Round = 103,
  PrimitiveType_Select = 104,
  PrimitiveType_Scatter = 105,
  PrimitiveType_ScatterND = 106,
  PrimitiveType_Unique = 107,
  PrimitiveType_Unstack = 108,
  PrimitiveType_LogicalAnd = 109,
  PrimitiveType_LogicalOr = 110,
  PrimitiveType_LogicalXor = 111,
  PrimitiveType_LogicalNot = 112,
  PrimitiveType_OnnxInt8Quantize = 113,
  PrimitiveType_OnnxInt8Dequantize = 114,
  PrimitiveType_FakeQuantWithMinMax = 115,
  PrimitiveType_FakeQuantWithMinMaxPerChannel = 116,
  PrimitiveType_BatchNormFold = 117,
  PrimitiveType_MulFold = 118,
  PrimitiveType_AddFold = 119,
  PrimitiveType_SquaredDifference = 120,
  PrimitiveType_Flatten = 121,
  PrimitiveType_TupleGetItem = 122,
  PrimitiveType_Div = 123,
  PrimitiveType_Where = 124,
  PrimitiveType_OneHot = 125,
  PrimitiveType_Lstm = 126,
  PrimitiveType_Conv2DGradFilter = 127,
  PrimitiveType_Conv2DGradInput = 128,
  PrimitiveType_PoolingGrad = 129,
  PrimitiveType_BNGradInput = 130,
  PrimitiveType_OptMomentum = 131,
  PrimitiveType_BiasGrad = 132,
  PrimitiveType_SoftmaxCrossEntropy = 133,
  PrimitiveType_AddGrad = 134,
  PrimitiveType_SubGrad = 135,
  PrimitiveType_MulGrad = 136,
  PrimitiveType_DivGrad = 137,
  PrimitiveType_PowerGrad = 138,
  PrimitiveType_ActivationGrad = 139,
  PrimitiveType_PriorBox = 140,
  PrimitiveType_SpaceToBatchND = 141,
  PrimitiveType_TopKV2 = 142,
  PrimitiveType_MIN = PrimitiveType_NONE,
  PrimitiveType_MAX = PrimitiveType_TopKV2
};

inline const PrimitiveType (&EnumValuesPrimitiveType())[143] {
  static const PrimitiveType values[] = {
    PrimitiveType_NONE,
    PrimitiveType_Concat,
    PrimitiveType_SoftMax,
    PrimitiveType_Activation,
    PrimitiveType_Conv2D,
    PrimitiveType_FusedBatchNorm,
    PrimitiveType_CaffeBatchNorm,
    PrimitiveType_BiasAdd,
    PrimitiveType_Pooling,
    PrimitiveType_DepthwiseConv2D,
    PrimitiveType_DeDepthwiseConv2D,
    PrimitiveType_Resize,
    PrimitiveType_DetectionPostProcess,
    PrimitiveType_FullConnection,
    PrimitiveType_Mean,
    PrimitiveType_DeConv2D,
    PrimitiveType_Scale,
    PrimitiveType_Reshape,
    PrimitiveType_Eltwise,
    PrimitiveType_NetOutput,
    PrimitiveType_Add,
    PrimitiveType_Sub,
    PrimitiveType_MatMul,
    PrimitiveType_StridedSlice,
    PrimitiveType_Power,
    PrimitiveType_Slice,
    PrimitiveType_Stack,
    PrimitiveType_Mul,
    PrimitiveType_RealDiv,
    PrimitiveType_Pad,
    PrimitiveType_Maximum,
    PrimitiveType_Minimum,
    PrimitiveType_CaffePReLU,
    PrimitiveType_LeakyReLU,
    PrimitiveType_ArgMax,
    PrimitiveType_ArgMin,
    PrimitiveType_Exp,
    PrimitiveType_Crop,
    PrimitiveType_Range,
    PrimitiveType_Rsqrt,
    PrimitiveType_ExpandDims,
    PrimitiveType_Tile,
    PrimitiveType_Cast,
    PrimitiveType_Shape,
    PrimitiveType_Nchw2Nhwc,
    PrimitiveType_Nhwc2Nchw,
    PrimitiveType_QuantDTypeCast,
    PrimitiveType_Split,
    PrimitiveType_Permute,
    PrimitiveType_FakeQuantWithMinMaxVars,
    PrimitiveType_Equal,
    PrimitiveType_Less,
    PrimitiveType_Greater,
    PrimitiveType_NotEqual,
    PrimitiveType_LessEqual,
    PrimitiveType_GreaterEqual,
    PrimitiveType_Min,
    PrimitiveType_Floor,
    PrimitiveType_Abs,
    PrimitiveType_Neg,
    PrimitiveType_Cos,
    PrimitiveType_Sin,
    PrimitiveType_Sqrt,
    PrimitiveType_Square,
    PrimitiveType_Constant,
    PrimitiveType_Log,
    PrimitiveType_Tan,
    PrimitiveType_Atan,
    PrimitiveType_Asin,
    PrimitiveType_Clip,
    PrimitiveType_Transpose,
    PrimitiveType_Squeeze,
    PrimitiveType_Unsqueeze,
    PrimitiveType_Upsample,
    PrimitiveType_Dropout,
    PrimitiveType_Broadcast,
    PrimitiveType_BroadcastTo,
    PrimitiveType_Lrn,
    PrimitiveType_Prelu,
    PrimitiveType_ZerosLike,
    PrimitiveType_TopK,
    PrimitiveType_SpaceToDepth,
    PrimitiveType_SpaceToBatch,
    PrimitiveType_SparseToDense,
    PrimitiveType_ReverseSequence,
    PrimitiveType_Rank,
    PrimitiveType_Gather,
    PrimitiveType_GatherNd,
    PrimitiveType_Fill,
    PrimitiveType_Elu,
    PrimitiveType_DepthToSpace,
    PrimitiveType_BatchToSpace,
    PrimitiveType_AddN,
    PrimitiveType_Ceil,
    PrimitiveType_EmbeddingLookup,
    PrimitiveType_EmbeddingLookupSparse,
    PrimitiveType_FloorDiv,
    PrimitiveType_FloorMod,
    PrimitiveType_L2Norm,
    PrimitiveType_LocalResponseNormalization,
    PrimitiveType_MatrixDiag,
    PrimitiveType_Reduce,
    PrimitiveType_Reverse,
    PrimitiveType_Round,
    PrimitiveType_Select,
    PrimitiveType_Scatter,
    PrimitiveType_ScatterND,
    PrimitiveType_Unique,
    PrimitiveType_Unstack,
    PrimitiveType_LogicalAnd,
    PrimitiveType_LogicalOr,
    PrimitiveType_LogicalXor,
    PrimitiveType_LogicalNot,
    PrimitiveType_OnnxInt8Quantize,
    PrimitiveType_OnnxInt8Dequantize,
    PrimitiveType_FakeQuantWithMinMax,
    PrimitiveType_FakeQuantWithMinMaxPerChannel,
    PrimitiveType_BatchNormFold,
    PrimitiveType_MulFold,
    PrimitiveType_AddFold,
    PrimitiveType_SquaredDifference,
    PrimitiveType_Flatten,
    PrimitiveType_TupleGetItem,
    PrimitiveType_Div,
    PrimitiveType_Where,
    PrimitiveType_OneHot,
    PrimitiveType_Lstm,
    PrimitiveType_Conv2DGradFilter,
    PrimitiveType_Conv2DGradInput,
    PrimitiveType_PoolingGrad,
    PrimitiveType_BNGradInput,
    PrimitiveType_OptMomentum,
    PrimitiveType_BiasGrad,
    PrimitiveType_SoftmaxCrossEntropy,
    PrimitiveType_AddGrad,
    PrimitiveType_SubGrad,
    PrimitiveType_MulGrad,
    PrimitiveType_DivGrad,
    PrimitiveType_PowerGrad,
    PrimitiveType_ActivationGrad,
    PrimitiveType_PriorBox,
    PrimitiveType_SpaceToBatchND,
    PrimitiveType_TopKV2
  };
  return values;
}

inline const char * const *EnumNamesPrimitiveType() {
  static const char * const names[] = {
    "NONE",
    "Concat",
    "SoftMax",
    "Activation",
    "Conv2D",
    "FusedBatchNorm",
    "CaffeBatchNorm",
    "BiasAdd",
    "Pooling",
    "DepthwiseConv2D",
    "DeDepthwiseConv2D",
    "Resize",
    "DetectionPostProcess",
    "FullConnection",
    "Mean",
    "DeConv2D",
    "Scale",
    "Reshape",
    "Eltwise",
    "NetOutput",
    "Add",
    "Sub",
    "MatMul",
    "StridedSlice",
    "Power",
    "Slice",
    "Stack",
    "Mul",
    "RealDiv",
    "Pad",
    "Maximum",
    "Minimum",
    "CaffePReLU",
    "LeakyReLU",
    "ArgMax",
    "ArgMin",
    "Exp",
    "Crop",
    "Range",
    "Rsqrt",
    "ExpandDims",
    "Tile",
    "Cast",
    "Shape",
    "Nchw2Nhwc",
    "Nhwc2Nchw",
    "QuantDTypeCast",
    "Split",
    "Permute",
    "FakeQuantWithMinMaxVars",
    "Equal",
    "Less",
    "Greater",
    "NotEqual",
    "LessEqual",
    "GreaterEqual",
    "Min",
    "Floor",
    "Abs",
    "Neg",
    "Cos",
    "Sin",
    "Sqrt",
    "Square",
    "Constant",
    "Log",
    "Tan",
    "Atan",
    "Asin",
    "Clip",
    "Transpose",
    "Squeeze",
    "Unsqueeze",
    "Upsample",
    "Dropout",
    "Broadcast",
    "BroadcastTo",
    "Lrn",
    "Prelu",
    "ZerosLike",
    "TopK",
    "SpaceToDepth",
    "SpaceToBatch",
    "SparseToDense",
    "ReverseSequence",
    "Rank",
    "Gather",
    "GatherNd",
    "Fill",
    "Elu",
    "DepthToSpace",
    "BatchToSpace",
    "AddN",
    "Ceil",
    "EmbeddingLookup",
    "EmbeddingLookupSparse",
    "FloorDiv",
    "FloorMod",
    "L2Norm",
    "LocalResponseNormalization",
    "MatrixDiag",
    "Reduce",
    "Reverse",
    "Round",
    "Select",
    "Scatter",
    "ScatterND",
    "Unique",
    "Unstack",
    "LogicalAnd",
    "LogicalOr",
    "LogicalXor",
    "LogicalNot",
    "OnnxInt8Quantize",
    "OnnxInt8Dequantize",
    "FakeQuantWithMinMax",
    "FakeQuantWithMinMaxPerChannel",
    "BatchNormFold",
    "MulFold",
    "AddFold",
    "SquaredDifference",
    "Flatten",
    "TupleGetItem",
    "Div",
    "Where",
    "OneHot",
    "Lstm",
    "Conv2DGradFilter",
    "Conv2DGradInput",
    "PoolingGrad",
    "BNGradInput",
    "OptMomentum",
    "BiasGrad",
    "SoftmaxCrossEntropy",
    "AddGrad",
    "SubGrad",
    "MulGrad",
    "DivGrad",
    "PowerGrad",
    "ActivationGrad",
    "PriorBox",
    "SpaceToBatchND",
    "TopKV2",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrimitiveType(PrimitiveType e) {
  if (e < PrimitiveType_NONE || e > PrimitiveType_TopKV2) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrimitiveType()[index];
}

template<typename T> struct PrimitiveTypeTraits {
  static const PrimitiveType enum_value = PrimitiveType_NONE;
};

template<> struct PrimitiveTypeTraits<Concat> {
  static const PrimitiveType enum_value = PrimitiveType_Concat;
};

template<> struct PrimitiveTypeTraits<SoftMax> {
  static const PrimitiveType enum_value = PrimitiveType_SoftMax;
};

template<> struct PrimitiveTypeTraits<Activation> {
  static const PrimitiveType enum_value = PrimitiveType_Activation;
};

template<> struct PrimitiveTypeTraits<Conv2D> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2D;
};

template<> struct PrimitiveTypeTraits<FusedBatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
};

template<> struct PrimitiveTypeTraits<CaffeBatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_CaffeBatchNorm;
};

template<> struct PrimitiveTypeTraits<BiasAdd> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
};

template<> struct PrimitiveTypeTraits<Pooling> {
  static const PrimitiveType enum_value = PrimitiveType_Pooling;
};

template<> struct PrimitiveTypeTraits<DepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<DeDepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeDepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<Resize> {
  static const PrimitiveType enum_value = PrimitiveType_Resize;
};

template<> struct PrimitiveTypeTraits<DetectionPostProcess> {
  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
};

template<> struct PrimitiveTypeTraits<FullConnection> {
  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
};

template<> struct PrimitiveTypeTraits<Mean> {
  static const PrimitiveType enum_value = PrimitiveType_Mean;
};

template<> struct PrimitiveTypeTraits<DeConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2D;
};

template<> struct PrimitiveTypeTraits<Scale> {
  static const PrimitiveType enum_value = PrimitiveType_Scale;
};

template<> struct PrimitiveTypeTraits<Reshape> {
  static const PrimitiveType enum_value = PrimitiveType_Reshape;
};

template<> struct PrimitiveTypeTraits<Eltwise> {
  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
};

template<> struct PrimitiveTypeTraits<NetOutput> {
  static const PrimitiveType enum_value = PrimitiveType_NetOutput;
};

template<> struct PrimitiveTypeTraits<Add> {
  static const PrimitiveType enum_value = PrimitiveType_Add;
};

template<> struct PrimitiveTypeTraits<Sub> {
  static const PrimitiveType enum_value = PrimitiveType_Sub;
};

template<> struct PrimitiveTypeTraits<MatMul> {
  static const PrimitiveType enum_value = PrimitiveType_MatMul;
};

template<> struct PrimitiveTypeTraits<StridedSlice> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
};

template<> struct PrimitiveTypeTraits<Power> {
  static const PrimitiveType enum_value = PrimitiveType_Power;
};

template<> struct PrimitiveTypeTraits<Slice> {
  static const PrimitiveType enum_value = PrimitiveType_Slice;
};

template<> struct PrimitiveTypeTraits<Stack> {
  static const PrimitiveType enum_value = PrimitiveType_Stack;
};

template<> struct PrimitiveTypeTraits<Mul> {
  static const PrimitiveType enum_value = PrimitiveType_Mul;
};

template<> struct PrimitiveTypeTraits<RealDiv> {
  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
};

template<> struct PrimitiveTypeTraits<Pad> {
  static const PrimitiveType enum_value = PrimitiveType_Pad;
};

template<> struct PrimitiveTypeTraits<Maximum> {
  static const PrimitiveType enum_value = PrimitiveType_Maximum;
};

template<> struct PrimitiveTypeTraits<Minimum> {
  static const PrimitiveType enum_value = PrimitiveType_Minimum;
};

template<> struct PrimitiveTypeTraits<CaffePReLU> {
  static const PrimitiveType enum_value = PrimitiveType_CaffePReLU;
};

template<> struct PrimitiveTypeTraits<LeakyReLU> {
  static const PrimitiveType enum_value = PrimitiveType_LeakyReLU;
};

template<> struct PrimitiveTypeTraits<ArgMax> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMax;
};

template<> struct PrimitiveTypeTraits<ArgMin> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMin;
};

template<> struct PrimitiveTypeTraits<Exp> {
  static const PrimitiveType enum_value = PrimitiveType_Exp;
};

template<> struct PrimitiveTypeTraits<Crop> {
  static const PrimitiveType enum_value = PrimitiveType_Crop;
};

template<> struct PrimitiveTypeTraits<Range> {
  static const PrimitiveType enum_value = PrimitiveType_Range;
};

template<> struct PrimitiveTypeTraits<Rsqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
};

template<> struct PrimitiveTypeTraits<ExpandDims> {
  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
};

template<> struct PrimitiveTypeTraits<Tile> {
  static const PrimitiveType enum_value = PrimitiveType_Tile;
};

template<> struct PrimitiveTypeTraits<Cast> {
  static const PrimitiveType enum_value = PrimitiveType_Cast;
};

template<> struct PrimitiveTypeTraits<Shape> {
  static const PrimitiveType enum_value = PrimitiveType_Shape;
};

template<> struct PrimitiveTypeTraits<Nchw2Nhwc> {
  static const PrimitiveType enum_value = PrimitiveType_Nchw2Nhwc;
};

template<> struct PrimitiveTypeTraits<Nhwc2Nchw> {
  static const PrimitiveType enum_value = PrimitiveType_Nhwc2Nchw;
};

template<> struct PrimitiveTypeTraits<QuantDTypeCast> {
  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
};

template<> struct PrimitiveTypeTraits<Split> {
  static const PrimitiveType enum_value = PrimitiveType_Split;
};

template<> struct PrimitiveTypeTraits<Permute> {
  static const PrimitiveType enum_value = PrimitiveType_Permute;
};

template<> struct PrimitiveTypeTraits<FakeQuantWithMinMaxVars> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
};

template<> struct PrimitiveTypeTraits<Equal> {
  static const PrimitiveType enum_value = PrimitiveType_Equal;
};

template<> struct PrimitiveTypeTraits<Less> {
  static const PrimitiveType enum_value = PrimitiveType_Less;
};

template<> struct PrimitiveTypeTraits<Greater> {
  static const PrimitiveType enum_value = PrimitiveType_Greater;
};

template<> struct PrimitiveTypeTraits<NotEqual> {
  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
};

template<> struct PrimitiveTypeTraits<LessEqual> {
  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
};

template<> struct PrimitiveTypeTraits<GreaterEqual> {
  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
};

template<> struct PrimitiveTypeTraits<Min> {
  static const PrimitiveType enum_value = PrimitiveType_Min;
};

template<> struct PrimitiveTypeTraits<Floor> {
  static const PrimitiveType enum_value = PrimitiveType_Floor;
};

template<> struct PrimitiveTypeTraits<Abs> {
  static const PrimitiveType enum_value = PrimitiveType_Abs;
};

template<> struct PrimitiveTypeTraits<Neg> {
  static const PrimitiveType enum_value = PrimitiveType_Neg;
};

template<> struct PrimitiveTypeTraits<Cos> {
  static const PrimitiveType enum_value = PrimitiveType_Cos;
};

template<> struct PrimitiveTypeTraits<Sin> {
  static const PrimitiveType enum_value = PrimitiveType_Sin;
};

template<> struct PrimitiveTypeTraits<Sqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
};

template<> struct PrimitiveTypeTraits<Square> {
  static const PrimitiveType enum_value = PrimitiveType_Square;
};

template<> struct PrimitiveTypeTraits<Constant> {
  static const PrimitiveType enum_value = PrimitiveType_Constant;
};

template<> struct PrimitiveTypeTraits<Log> {
  static const PrimitiveType enum_value = PrimitiveType_Log;
};

template<> struct PrimitiveTypeTraits<Tan> {
  static const PrimitiveType enum_value = PrimitiveType_Tan;
};

template<> struct PrimitiveTypeTraits<Atan> {
  static const PrimitiveType enum_value = PrimitiveType_Atan;
};

template<> struct PrimitiveTypeTraits<Asin> {
  static const PrimitiveType enum_value = PrimitiveType_Asin;
};

template<> struct PrimitiveTypeTraits<Clip> {
  static const PrimitiveType enum_value = PrimitiveType_Clip;
};

template<> struct PrimitiveTypeTraits<Transpose> {
  static const PrimitiveType enum_value = PrimitiveType_Transpose;
};

template<> struct PrimitiveTypeTraits<Squeeze> {
  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
};

template<> struct PrimitiveTypeTraits<Unsqueeze> {
  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
};

template<> struct PrimitiveTypeTraits<Upsample> {
  static const PrimitiveType enum_value = PrimitiveType_Upsample;
};

template<> struct PrimitiveTypeTraits<Dropout> {
  static const PrimitiveType enum_value = PrimitiveType_Dropout;
};

template<> struct PrimitiveTypeTraits<Broadcast> {
  static const PrimitiveType enum_value = PrimitiveType_Broadcast;
};

template<> struct PrimitiveTypeTraits<BroadcastTo> {
  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
};

template<> struct PrimitiveTypeTraits<Lrn> {
  static const PrimitiveType enum_value = PrimitiveType_Lrn;
};

template<> struct PrimitiveTypeTraits<Prelu> {
  static const PrimitiveType enum_value = PrimitiveType_Prelu;
};

template<> struct PrimitiveTypeTraits<ZerosLike> {
  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
};

template<> struct PrimitiveTypeTraits<TopK> {
  static const PrimitiveType enum_value = PrimitiveType_TopK;
};

template<> struct PrimitiveTypeTraits<SpaceToDepth> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
};

template<> struct PrimitiveTypeTraits<SpaceToBatch> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
};

template<> struct PrimitiveTypeTraits<SparseToDense> {
  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
};

template<> struct PrimitiveTypeTraits<ReverseSequence> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
};

template<> struct PrimitiveTypeTraits<Rank> {
  static const PrimitiveType enum_value = PrimitiveType_Rank;
};

template<> struct PrimitiveTypeTraits<Gather> {
  static const PrimitiveType enum_value = PrimitiveType_Gather;
};

template<> struct PrimitiveTypeTraits<GatherNd> {
  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
};

template<> struct PrimitiveTypeTraits<Fill> {
  static const PrimitiveType enum_value = PrimitiveType_Fill;
};

template<> struct PrimitiveTypeTraits<Elu> {
  static const PrimitiveType enum_value = PrimitiveType_Elu;
};

template<> struct PrimitiveTypeTraits<DepthToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
};

template<> struct PrimitiveTypeTraits<BatchToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
};

template<> struct PrimitiveTypeTraits<AddN> {
  static const PrimitiveType enum_value = PrimitiveType_AddN;
};

template<> struct PrimitiveTypeTraits<Ceil> {
  static const PrimitiveType enum_value = PrimitiveType_Ceil;
};

template<> struct PrimitiveTypeTraits<EmbeddingLookup> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookup;
};

template<> struct PrimitiveTypeTraits<EmbeddingLookupSparse> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupSparse;
};

template<> struct PrimitiveTypeTraits<FloorDiv> {
  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
};

template<> struct PrimitiveTypeTraits<FloorMod> {
  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
};

template<> struct PrimitiveTypeTraits<L2Norm> {
  static const PrimitiveType enum_value = PrimitiveType_L2Norm;
};

template<> struct PrimitiveTypeTraits<LocalResponseNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LocalResponseNormalization;
};

template<> struct PrimitiveTypeTraits<MatrixDiag> {
  static const PrimitiveType enum_value = PrimitiveType_MatrixDiag;
};

template<> struct PrimitiveTypeTraits<Reduce> {
  static const PrimitiveType enum_value = PrimitiveType_Reduce;
};

template<> struct PrimitiveTypeTraits<Reverse> {
  static const PrimitiveType enum_value = PrimitiveType_Reverse;
};

template<> struct PrimitiveTypeTraits<Round> {
  static const PrimitiveType enum_value = PrimitiveType_Round;
};

template<> struct PrimitiveTypeTraits<Select> {
  static const PrimitiveType enum_value = PrimitiveType_Select;
};

template<> struct PrimitiveTypeTraits<Scatter> {
  static const PrimitiveType enum_value = PrimitiveType_Scatter;
};

template<> struct PrimitiveTypeTraits<ScatterND> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterND;
};

template<> struct PrimitiveTypeTraits<Unique> {
  static const PrimitiveType enum_value = PrimitiveType_Unique;
};

template<> struct PrimitiveTypeTraits<Unstack> {
  static const PrimitiveType enum_value = PrimitiveType_Unstack;
};

template<> struct PrimitiveTypeTraits<LogicalAnd> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
};

template<> struct PrimitiveTypeTraits<LogicalOr> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
};

template<> struct PrimitiveTypeTraits<LogicalXor> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalXor;
};

template<> struct PrimitiveTypeTraits<LogicalNot> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
};

template<> struct PrimitiveTypeTraits<OnnxInt8Quantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Quantize;
};

template<> struct PrimitiveTypeTraits<OnnxInt8Dequantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Dequantize;
};

template<> struct PrimitiveTypeTraits<FakeQuantWithMinMax> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMax;
};

template<> struct PrimitiveTypeTraits<FakeQuantWithMinMaxPerChannel> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxPerChannel;
};

template<> struct PrimitiveTypeTraits<BatchNormFold> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNormFold;
};

template<> struct PrimitiveTypeTraits<MulFold> {
  static const PrimitiveType enum_value = PrimitiveType_MulFold;
};

template<> struct PrimitiveTypeTraits<AddFold> {
  static const PrimitiveType enum_value = PrimitiveType_AddFold;
};

template<> struct PrimitiveTypeTraits<SquaredDifference> {
  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
};

template<> struct PrimitiveTypeTraits<Flatten> {
  static const PrimitiveType enum_value = PrimitiveType_Flatten;
};

template<> struct PrimitiveTypeTraits<TupleGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TupleGetItem;
};

template<> struct PrimitiveTypeTraits<Div> {
  static const PrimitiveType enum_value = PrimitiveType_Div;
};

template<> struct PrimitiveTypeTraits<Where> {
  static const PrimitiveType enum_value = PrimitiveType_Where;
};

template<> struct PrimitiveTypeTraits<OneHot> {
  static const PrimitiveType enum_value = PrimitiveType_OneHot;
};

template<> struct PrimitiveTypeTraits<Lstm> {
  static const PrimitiveType enum_value = PrimitiveType_Lstm;
};

template<> struct PrimitiveTypeTraits<Conv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<Conv2DGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradInput;
};

template<> struct PrimitiveTypeTraits<PoolingGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PoolingGrad;
};

template<> struct PrimitiveTypeTraits<BNGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_BNGradInput;
};

template<> struct PrimitiveTypeTraits<OptMomentum> {
  static const PrimitiveType enum_value = PrimitiveType_OptMomentum;
};

template<> struct PrimitiveTypeTraits<BiasGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BiasGrad;
};

template<> struct PrimitiveTypeTraits<SoftmaxCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropy;
};

template<> struct PrimitiveTypeTraits<AddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
};

template<> struct PrimitiveTypeTraits<SubGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
};

template<> struct PrimitiveTypeTraits<MulGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
};

template<> struct PrimitiveTypeTraits<DivGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
};

template<> struct PrimitiveTypeTraits<PowerGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
};

template<> struct PrimitiveTypeTraits<ActivationGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
};

template<> struct PrimitiveTypeTraits<PriorBox> {
  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
};

template<> struct PrimitiveTypeTraits<SpaceToBatchND> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
};

template<> struct PrimitiveTypeTraits<TopKV2> {
  static const PrimitiveType enum_value = PrimitiveType_TopKV2;
};

bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum QuantType {
  QuantType_QUANT_NONE = 0,
  QuantType_AwareTrainning = 1,
  QuantType_WeightQuant = 2,
  QuantType_PostTraining = 3,
  QuantType_MIN = QuantType_QUANT_NONE,
  QuantType_MAX = QuantType_PostTraining
};

inline const QuantType (&EnumValuesQuantType())[4] {
  static const QuantType values[] = {
    QuantType_QUANT_NONE,
    QuantType_AwareTrainning,
    QuantType_WeightQuant,
    QuantType_PostTraining
  };
  return values;
}

inline const char * const *EnumNamesQuantType() {
  static const char * const names[] = {
    "QUANT_NONE",
    "AwareTrainning",
    "WeightQuant",
    "PostTraining",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantType(QuantType e) {
  if (e < QuantType_QUANT_NONE || e > QuantType_PostTraining) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantType()[index];
}

struct QuantParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZEROPOINT = 6,
    VT_MIN = 8,
    VT_MAX = 10,
    VT_NARROWRANGE = 12,
    VT_NUMBITS = 14,
    VT_INITED = 16
  };
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  int32_t zeroPoint() const {
    return GetField<int32_t>(VT_ZEROPOINT, 0);
  }
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  bool narrowRange() const {
    return GetField<uint8_t>(VT_NARROWRANGE, 1) != 0;
  }
  int32_t numBits() const {
    return GetField<int32_t>(VT_NUMBITS, 8);
  }
  bool inited() const {
    return GetField<uint8_t>(VT_INITED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_ZEROPOINT) &&
           VerifyField<double>(verifier, VT_MIN) &&
           VerifyField<double>(verifier, VT_MAX) &&
           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
           VerifyField<uint8_t>(verifier, VT_INITED) &&
           verifier.EndTable();
  }
};

struct QuantParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(double scale) {
    fbb_.AddElement<double>(QuantParam::VT_SCALE, scale, 0.0);
  }
  void add_zeroPoint(int32_t zeroPoint) {
    fbb_.AddElement<int32_t>(QuantParam::VT_ZEROPOINT, zeroPoint, 0);
  }
  void add_min(double min) {
    fbb_.AddElement<double>(QuantParam::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(QuantParam::VT_MAX, max, 0.0);
  }
  void add_narrowRange(bool narrowRange) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 1);
  }
  void add_numBits(int32_t numBits) {
    fbb_.AddElement<int32_t>(QuantParam::VT_NUMBITS, numBits, 8);
  }
  void add_inited(bool inited) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_INITED, static_cast<uint8_t>(inited), 0);
  }
  explicit QuantParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantParamBuilder &operator=(const QuantParamBuilder &);
  flatbuffers::Offset<QuantParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantParam> CreateQuantParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scale = 0.0,
    int32_t zeroPoint = 0,
    double min = 0.0,
    double max = 0.0,
    bool narrowRange = true,
    int32_t numBits = 8,
    bool inited = false) {
  QuantParamBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_scale(scale);
  builder_.add_numBits(numBits);
  builder_.add_zeroPoint(zeroPoint);
  builder_.add_inited(inited);
  builder_.add_narrowRange(narrowRange);
  return builder_.Finish();
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODETYPE = 4,
    VT_DATATYPE = 6,
    VT_DIMS = 8,
    VT_FORMAT = 10,
    VT_REFCOUNT = 12,
    VT_OFFSET = 14,
    VT_DATA = 16,
    VT_QUANTPARAMS = 18
  };
  NodeType nodeType() const {
    return static_cast<NodeType>(GetField<int32_t>(VT_NODETYPE, 0));
  }
  int32_t dataType() const {
    return GetField<int32_t>(VT_DATATYPE, 0);
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t refCount() const {
    return GetField<int32_t>(VT_REFCOUNT, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<QuantParam>> *quantParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QuantParam>> *>(VT_QUANTPARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_REFCOUNT) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_QUANTPARAMS) &&
           verifier.VerifyVector(quantParams()) &&
           verifier.VerifyVectorOfTables(quantParams()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeType(NodeType nodeType) {
    fbb_.AddElement<int32_t>(Tensor::VT_NODETYPE, static_cast<int32_t>(nodeType), 0);
  }
  void add_dataType(int32_t dataType) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATATYPE, dataType, 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Tensor::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_refCount(int32_t refCount) {
    fbb_.AddElement<int32_t>(Tensor::VT_REFCOUNT, refCount, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(Tensor::VT_OFFSET, offset, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  void add_quantParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuantParam>>> quantParams) {
    fbb_.AddOffset(Tensor::VT_QUANTPARAMS, quantParams);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeType nodeType = NodeType_ValueNode,
    int32_t dataType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    Format format = Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuantParam>>> quantParams = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_quantParams(quantParams);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_refCount(refCount);
  builder_.add_format(format);
  builder_.add_dims(dims);
  builder_.add_dataType(dataType);
  builder_.add_nodeType(nodeType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeType nodeType = NodeType_ValueNode,
    int32_t dataType = 0,
    const std::vector<int32_t> *dims = nullptr,
    Format format = Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<flatbuffers::Offset<QuantParam>> *quantParams = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto quantParams__ = quantParams ? _fbb.CreateVector<flatbuffers::Offset<QuantParam>>(*quantParams) : 0;
  return mindspore::schema::CreateTensor(
      _fbb,
      nodeType,
      dataType,
      dims__,
      format,
      refCount,
      offset,
      data__,
      quantParams__);
}

struct Primitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  PrimitiveType value_type() const {
    return static_cast<PrimitiveType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Concat *value_as_Concat() const {
    return value_type() == PrimitiveType_Concat ? static_cast<const Concat *>(value()) : nullptr;
  }
  const SoftMax *value_as_SoftMax() const {
    return value_type() == PrimitiveType_SoftMax ? static_cast<const SoftMax *>(value()) : nullptr;
  }
  const Activation *value_as_Activation() const {
    return value_type() == PrimitiveType_Activation ? static_cast<const Activation *>(value()) : nullptr;
  }
  const Conv2D *value_as_Conv2D() const {
    return value_type() == PrimitiveType_Conv2D ? static_cast<const Conv2D *>(value()) : nullptr;
  }
  const FusedBatchNorm *value_as_FusedBatchNorm() const {
    return value_type() == PrimitiveType_FusedBatchNorm ? static_cast<const FusedBatchNorm *>(value()) : nullptr;
  }
  const CaffeBatchNorm *value_as_CaffeBatchNorm() const {
    return value_type() == PrimitiveType_CaffeBatchNorm ? static_cast<const CaffeBatchNorm *>(value()) : nullptr;
  }
  const BiasAdd *value_as_BiasAdd() const {
    return value_type() == PrimitiveType_BiasAdd ? static_cast<const BiasAdd *>(value()) : nullptr;
  }
  const Pooling *value_as_Pooling() const {
    return value_type() == PrimitiveType_Pooling ? static_cast<const Pooling *>(value()) : nullptr;
  }
  const DepthwiseConv2D *value_as_DepthwiseConv2D() const {
    return value_type() == PrimitiveType_DepthwiseConv2D ? static_cast<const DepthwiseConv2D *>(value()) : nullptr;
  }
  const DeDepthwiseConv2D *value_as_DeDepthwiseConv2D() const {
    return value_type() == PrimitiveType_DeDepthwiseConv2D ? static_cast<const DeDepthwiseConv2D *>(value()) : nullptr;
  }
  const Resize *value_as_Resize() const {
    return value_type() == PrimitiveType_Resize ? static_cast<const Resize *>(value()) : nullptr;
  }
  const DetectionPostProcess *value_as_DetectionPostProcess() const {
    return value_type() == PrimitiveType_DetectionPostProcess ? static_cast<const DetectionPostProcess *>(value()) : nullptr;
  }
  const FullConnection *value_as_FullConnection() const {
    return value_type() == PrimitiveType_FullConnection ? static_cast<const FullConnection *>(value()) : nullptr;
  }
  const Mean *value_as_Mean() const {
    return value_type() == PrimitiveType_Mean ? static_cast<const Mean *>(value()) : nullptr;
  }
  const DeConv2D *value_as_DeConv2D() const {
    return value_type() == PrimitiveType_DeConv2D ? static_cast<const DeConv2D *>(value()) : nullptr;
  }
  const Scale *value_as_Scale() const {
    return value_type() == PrimitiveType_Scale ? static_cast<const Scale *>(value()) : nullptr;
  }
  const Reshape *value_as_Reshape() const {
    return value_type() == PrimitiveType_Reshape ? static_cast<const Reshape *>(value()) : nullptr;
  }
  const Eltwise *value_as_Eltwise() const {
    return value_type() == PrimitiveType_Eltwise ? static_cast<const Eltwise *>(value()) : nullptr;
  }
  const NetOutput *value_as_NetOutput() const {
    return value_type() == PrimitiveType_NetOutput ? static_cast<const NetOutput *>(value()) : nullptr;
  }
  const Add *value_as_Add() const {
    return value_type() == PrimitiveType_Add ? static_cast<const Add *>(value()) : nullptr;
  }
  const Sub *value_as_Sub() const {
    return value_type() == PrimitiveType_Sub ? static_cast<const Sub *>(value()) : nullptr;
  }
  const MatMul *value_as_MatMul() const {
    return value_type() == PrimitiveType_MatMul ? static_cast<const MatMul *>(value()) : nullptr;
  }
  const StridedSlice *value_as_StridedSlice() const {
    return value_type() == PrimitiveType_StridedSlice ? static_cast<const StridedSlice *>(value()) : nullptr;
  }
  const Power *value_as_Power() const {
    return value_type() == PrimitiveType_Power ? static_cast<const Power *>(value()) : nullptr;
  }
  const Slice *value_as_Slice() const {
    return value_type() == PrimitiveType_Slice ? static_cast<const Slice *>(value()) : nullptr;
  }
  const Stack *value_as_Stack() const {
    return value_type() == PrimitiveType_Stack ? static_cast<const Stack *>(value()) : nullptr;
  }
  const Mul *value_as_Mul() const {
    return value_type() == PrimitiveType_Mul ? static_cast<const Mul *>(value()) : nullptr;
  }
  const RealDiv *value_as_RealDiv() const {
    return value_type() == PrimitiveType_RealDiv ? static_cast<const RealDiv *>(value()) : nullptr;
  }
  const Pad *value_as_Pad() const {
    return value_type() == PrimitiveType_Pad ? static_cast<const Pad *>(value()) : nullptr;
  }
  const Maximum *value_as_Maximum() const {
    return value_type() == PrimitiveType_Maximum ? static_cast<const Maximum *>(value()) : nullptr;
  }
  const Minimum *value_as_Minimum() const {
    return value_type() == PrimitiveType_Minimum ? static_cast<const Minimum *>(value()) : nullptr;
  }
  const CaffePReLU *value_as_CaffePReLU() const {
    return value_type() == PrimitiveType_CaffePReLU ? static_cast<const CaffePReLU *>(value()) : nullptr;
  }
  const LeakyReLU *value_as_LeakyReLU() const {
    return value_type() == PrimitiveType_LeakyReLU ? static_cast<const LeakyReLU *>(value()) : nullptr;
  }
  const ArgMax *value_as_ArgMax() const {
    return value_type() == PrimitiveType_ArgMax ? static_cast<const ArgMax *>(value()) : nullptr;
  }
  const ArgMin *value_as_ArgMin() const {
    return value_type() == PrimitiveType_ArgMin ? static_cast<const ArgMin *>(value()) : nullptr;
  }
  const Exp *value_as_Exp() const {
    return value_type() == PrimitiveType_Exp ? static_cast<const Exp *>(value()) : nullptr;
  }
  const Crop *value_as_Crop() const {
    return value_type() == PrimitiveType_Crop ? static_cast<const Crop *>(value()) : nullptr;
  }
  const Range *value_as_Range() const {
    return value_type() == PrimitiveType_Range ? static_cast<const Range *>(value()) : nullptr;
  }
  const Rsqrt *value_as_Rsqrt() const {
    return value_type() == PrimitiveType_Rsqrt ? static_cast<const Rsqrt *>(value()) : nullptr;
  }
  const ExpandDims *value_as_ExpandDims() const {
    return value_type() == PrimitiveType_ExpandDims ? static_cast<const ExpandDims *>(value()) : nullptr;
  }
  const Tile *value_as_Tile() const {
    return value_type() == PrimitiveType_Tile ? static_cast<const Tile *>(value()) : nullptr;
  }
  const Cast *value_as_Cast() const {
    return value_type() == PrimitiveType_Cast ? static_cast<const Cast *>(value()) : nullptr;
  }
  const Shape *value_as_Shape() const {
    return value_type() == PrimitiveType_Shape ? static_cast<const Shape *>(value()) : nullptr;
  }
  const Nchw2Nhwc *value_as_Nchw2Nhwc() const {
    return value_type() == PrimitiveType_Nchw2Nhwc ? static_cast<const Nchw2Nhwc *>(value()) : nullptr;
  }
  const Nhwc2Nchw *value_as_Nhwc2Nchw() const {
    return value_type() == PrimitiveType_Nhwc2Nchw ? static_cast<const Nhwc2Nchw *>(value()) : nullptr;
  }
  const QuantDTypeCast *value_as_QuantDTypeCast() const {
    return value_type() == PrimitiveType_QuantDTypeCast ? static_cast<const QuantDTypeCast *>(value()) : nullptr;
  }
  const Split *value_as_Split() const {
    return value_type() == PrimitiveType_Split ? static_cast<const Split *>(value()) : nullptr;
  }
  const Permute *value_as_Permute() const {
    return value_type() == PrimitiveType_Permute ? static_cast<const Permute *>(value()) : nullptr;
  }
  const FakeQuantWithMinMaxVars *value_as_FakeQuantWithMinMaxVars() const {
    return value_type() == PrimitiveType_FakeQuantWithMinMaxVars ? static_cast<const FakeQuantWithMinMaxVars *>(value()) : nullptr;
  }
  const Equal *value_as_Equal() const {
    return value_type() == PrimitiveType_Equal ? static_cast<const Equal *>(value()) : nullptr;
  }
  const Less *value_as_Less() const {
    return value_type() == PrimitiveType_Less ? static_cast<const Less *>(value()) : nullptr;
  }
  const Greater *value_as_Greater() const {
    return value_type() == PrimitiveType_Greater ? static_cast<const Greater *>(value()) : nullptr;
  }
  const NotEqual *value_as_NotEqual() const {
    return value_type() == PrimitiveType_NotEqual ? static_cast<const NotEqual *>(value()) : nullptr;
  }
  const LessEqual *value_as_LessEqual() const {
    return value_type() == PrimitiveType_LessEqual ? static_cast<const LessEqual *>(value()) : nullptr;
  }
  const GreaterEqual *value_as_GreaterEqual() const {
    return value_type() == PrimitiveType_GreaterEqual ? static_cast<const GreaterEqual *>(value()) : nullptr;
  }
  const Min *value_as_Min() const {
    return value_type() == PrimitiveType_Min ? static_cast<const Min *>(value()) : nullptr;
  }
  const Floor *value_as_Floor() const {
    return value_type() == PrimitiveType_Floor ? static_cast<const Floor *>(value()) : nullptr;
  }
  const Abs *value_as_Abs() const {
    return value_type() == PrimitiveType_Abs ? static_cast<const Abs *>(value()) : nullptr;
  }
  const Neg *value_as_Neg() const {
    return value_type() == PrimitiveType_Neg ? static_cast<const Neg *>(value()) : nullptr;
  }
  const Cos *value_as_Cos() const {
    return value_type() == PrimitiveType_Cos ? static_cast<const Cos *>(value()) : nullptr;
  }
  const Sin *value_as_Sin() const {
    return value_type() == PrimitiveType_Sin ? static_cast<const Sin *>(value()) : nullptr;
  }
  const Sqrt *value_as_Sqrt() const {
    return value_type() == PrimitiveType_Sqrt ? static_cast<const Sqrt *>(value()) : nullptr;
  }
  const Square *value_as_Square() const {
    return value_type() == PrimitiveType_Square ? static_cast<const Square *>(value()) : nullptr;
  }
  const Constant *value_as_Constant() const {
    return value_type() == PrimitiveType_Constant ? static_cast<const Constant *>(value()) : nullptr;
  }
  const Log *value_as_Log() const {
    return value_type() == PrimitiveType_Log ? static_cast<const Log *>(value()) : nullptr;
  }
  const Tan *value_as_Tan() const {
    return value_type() == PrimitiveType_Tan ? static_cast<const Tan *>(value()) : nullptr;
  }
  const Atan *value_as_Atan() const {
    return value_type() == PrimitiveType_Atan ? static_cast<const Atan *>(value()) : nullptr;
  }
  const Asin *value_as_Asin() const {
    return value_type() == PrimitiveType_Asin ? static_cast<const Asin *>(value()) : nullptr;
  }
  const Clip *value_as_Clip() const {
    return value_type() == PrimitiveType_Clip ? static_cast<const Clip *>(value()) : nullptr;
  }
  const Transpose *value_as_Transpose() const {
    return value_type() == PrimitiveType_Transpose ? static_cast<const Transpose *>(value()) : nullptr;
  }
  const Squeeze *value_as_Squeeze() const {
    return value_type() == PrimitiveType_Squeeze ? static_cast<const Squeeze *>(value()) : nullptr;
  }
  const Unsqueeze *value_as_Unsqueeze() const {
    return value_type() == PrimitiveType_Unsqueeze ? static_cast<const Unsqueeze *>(value()) : nullptr;
  }
  const Upsample *value_as_Upsample() const {
    return value_type() == PrimitiveType_Upsample ? static_cast<const Upsample *>(value()) : nullptr;
  }
  const Dropout *value_as_Dropout() const {
    return value_type() == PrimitiveType_Dropout ? static_cast<const Dropout *>(value()) : nullptr;
  }
  const Broadcast *value_as_Broadcast() const {
    return value_type() == PrimitiveType_Broadcast ? static_cast<const Broadcast *>(value()) : nullptr;
  }
  const BroadcastTo *value_as_BroadcastTo() const {
    return value_type() == PrimitiveType_BroadcastTo ? static_cast<const BroadcastTo *>(value()) : nullptr;
  }
  const Lrn *value_as_Lrn() const {
    return value_type() == PrimitiveType_Lrn ? static_cast<const Lrn *>(value()) : nullptr;
  }
  const Prelu *value_as_Prelu() const {
    return value_type() == PrimitiveType_Prelu ? static_cast<const Prelu *>(value()) : nullptr;
  }
  const ZerosLike *value_as_ZerosLike() const {
    return value_type() == PrimitiveType_ZerosLike ? static_cast<const ZerosLike *>(value()) : nullptr;
  }
  const TopK *value_as_TopK() const {
    return value_type() == PrimitiveType_TopK ? static_cast<const TopK *>(value()) : nullptr;
  }
  const SpaceToDepth *value_as_SpaceToDepth() const {
    return value_type() == PrimitiveType_SpaceToDepth ? static_cast<const SpaceToDepth *>(value()) : nullptr;
  }
  const SpaceToBatch *value_as_SpaceToBatch() const {
    return value_type() == PrimitiveType_SpaceToBatch ? static_cast<const SpaceToBatch *>(value()) : nullptr;
  }
  const SparseToDense *value_as_SparseToDense() const {
    return value_type() == PrimitiveType_SparseToDense ? static_cast<const SparseToDense *>(value()) : nullptr;
  }
  const ReverseSequence *value_as_ReverseSequence() const {
    return value_type() == PrimitiveType_ReverseSequence ? static_cast<const ReverseSequence *>(value()) : nullptr;
  }
  const Rank *value_as_Rank() const {
    return value_type() == PrimitiveType_Rank ? static_cast<const Rank *>(value()) : nullptr;
  }
  const Gather *value_as_Gather() const {
    return value_type() == PrimitiveType_Gather ? static_cast<const Gather *>(value()) : nullptr;
  }
  const GatherNd *value_as_GatherNd() const {
    return value_type() == PrimitiveType_GatherNd ? static_cast<const GatherNd *>(value()) : nullptr;
  }
  const Fill *value_as_Fill() const {
    return value_type() == PrimitiveType_Fill ? static_cast<const Fill *>(value()) : nullptr;
  }
  const Elu *value_as_Elu() const {
    return value_type() == PrimitiveType_Elu ? static_cast<const Elu *>(value()) : nullptr;
  }
  const DepthToSpace *value_as_DepthToSpace() const {
    return value_type() == PrimitiveType_DepthToSpace ? static_cast<const DepthToSpace *>(value()) : nullptr;
  }
  const BatchToSpace *value_as_BatchToSpace() const {
    return value_type() == PrimitiveType_BatchToSpace ? static_cast<const BatchToSpace *>(value()) : nullptr;
  }
  const AddN *value_as_AddN() const {
    return value_type() == PrimitiveType_AddN ? static_cast<const AddN *>(value()) : nullptr;
  }
  const Ceil *value_as_Ceil() const {
    return value_type() == PrimitiveType_Ceil ? static_cast<const Ceil *>(value()) : nullptr;
  }
  const EmbeddingLookup *value_as_EmbeddingLookup() const {
    return value_type() == PrimitiveType_EmbeddingLookup ? static_cast<const EmbeddingLookup *>(value()) : nullptr;
  }
  const EmbeddingLookupSparse *value_as_EmbeddingLookupSparse() const {
    return value_type() == PrimitiveType_EmbeddingLookupSparse ? static_cast<const EmbeddingLookupSparse *>(value()) : nullptr;
  }
  const FloorDiv *value_as_FloorDiv() const {
    return value_type() == PrimitiveType_FloorDiv ? static_cast<const FloorDiv *>(value()) : nullptr;
  }
  const FloorMod *value_as_FloorMod() const {
    return value_type() == PrimitiveType_FloorMod ? static_cast<const FloorMod *>(value()) : nullptr;
  }
  const L2Norm *value_as_L2Norm() const {
    return value_type() == PrimitiveType_L2Norm ? static_cast<const L2Norm *>(value()) : nullptr;
  }
  const LocalResponseNormalization *value_as_LocalResponseNormalization() const {
    return value_type() == PrimitiveType_LocalResponseNormalization ? static_cast<const LocalResponseNormalization *>(value()) : nullptr;
  }
  const MatrixDiag *value_as_MatrixDiag() const {
    return value_type() == PrimitiveType_MatrixDiag ? static_cast<const MatrixDiag *>(value()) : nullptr;
  }
  const Reduce *value_as_Reduce() const {
    return value_type() == PrimitiveType_Reduce ? static_cast<const Reduce *>(value()) : nullptr;
  }
  const Reverse *value_as_Reverse() const {
    return value_type() == PrimitiveType_Reverse ? static_cast<const Reverse *>(value()) : nullptr;
  }
  const Round *value_as_Round() const {
    return value_type() == PrimitiveType_Round ? static_cast<const Round *>(value()) : nullptr;
  }
  const Select *value_as_Select() const {
    return value_type() == PrimitiveType_Select ? static_cast<const Select *>(value()) : nullptr;
  }
  const Scatter *value_as_Scatter() const {
    return value_type() == PrimitiveType_Scatter ? static_cast<const Scatter *>(value()) : nullptr;
  }
  const ScatterND *value_as_ScatterND() const {
    return value_type() == PrimitiveType_ScatterND ? static_cast<const ScatterND *>(value()) : nullptr;
  }
  const Unique *value_as_Unique() const {
    return value_type() == PrimitiveType_Unique ? static_cast<const Unique *>(value()) : nullptr;
  }
  const Unstack *value_as_Unstack() const {
    return value_type() == PrimitiveType_Unstack ? static_cast<const Unstack *>(value()) : nullptr;
  }
  const LogicalAnd *value_as_LogicalAnd() const {
    return value_type() == PrimitiveType_LogicalAnd ? static_cast<const LogicalAnd *>(value()) : nullptr;
  }
  const LogicalOr *value_as_LogicalOr() const {
    return value_type() == PrimitiveType_LogicalOr ? static_cast<const LogicalOr *>(value()) : nullptr;
  }
  const LogicalXor *value_as_LogicalXor() const {
    return value_type() == PrimitiveType_LogicalXor ? static_cast<const LogicalXor *>(value()) : nullptr;
  }
  const LogicalNot *value_as_LogicalNot() const {
    return value_type() == PrimitiveType_LogicalNot ? static_cast<const LogicalNot *>(value()) : nullptr;
  }
  const OnnxInt8Quantize *value_as_OnnxInt8Quantize() const {
    return value_type() == PrimitiveType_OnnxInt8Quantize ? static_cast<const OnnxInt8Quantize *>(value()) : nullptr;
  }
  const OnnxInt8Dequantize *value_as_OnnxInt8Dequantize() const {
    return value_type() == PrimitiveType_OnnxInt8Dequantize ? static_cast<const OnnxInt8Dequantize *>(value()) : nullptr;
  }
  const FakeQuantWithMinMax *value_as_FakeQuantWithMinMax() const {
    return value_type() == PrimitiveType_FakeQuantWithMinMax ? static_cast<const FakeQuantWithMinMax *>(value()) : nullptr;
  }
  const FakeQuantWithMinMaxPerChannel *value_as_FakeQuantWithMinMaxPerChannel() const {
    return value_type() == PrimitiveType_FakeQuantWithMinMaxPerChannel ? static_cast<const FakeQuantWithMinMaxPerChannel *>(value()) : nullptr;
  }
  const BatchNormFold *value_as_BatchNormFold() const {
    return value_type() == PrimitiveType_BatchNormFold ? static_cast<const BatchNormFold *>(value()) : nullptr;
  }
  const MulFold *value_as_MulFold() const {
    return value_type() == PrimitiveType_MulFold ? static_cast<const MulFold *>(value()) : nullptr;
  }
  const AddFold *value_as_AddFold() const {
    return value_type() == PrimitiveType_AddFold ? static_cast<const AddFold *>(value()) : nullptr;
  }
  const SquaredDifference *value_as_SquaredDifference() const {
    return value_type() == PrimitiveType_SquaredDifference ? static_cast<const SquaredDifference *>(value()) : nullptr;
  }
  const Flatten *value_as_Flatten() const {
    return value_type() == PrimitiveType_Flatten ? static_cast<const Flatten *>(value()) : nullptr;
  }
  const TupleGetItem *value_as_TupleGetItem() const {
    return value_type() == PrimitiveType_TupleGetItem ? static_cast<const TupleGetItem *>(value()) : nullptr;
  }
  const Div *value_as_Div() const {
    return value_type() == PrimitiveType_Div ? static_cast<const Div *>(value()) : nullptr;
  }
  const Where *value_as_Where() const {
    return value_type() == PrimitiveType_Where ? static_cast<const Where *>(value()) : nullptr;
  }
  const OneHot *value_as_OneHot() const {
    return value_type() == PrimitiveType_OneHot ? static_cast<const OneHot *>(value()) : nullptr;
  }
  const Lstm *value_as_Lstm() const {
    return value_type() == PrimitiveType_Lstm ? static_cast<const Lstm *>(value()) : nullptr;
  }
  const Conv2DGradFilter *value_as_Conv2DGradFilter() const {
    return value_type() == PrimitiveType_Conv2DGradFilter ? static_cast<const Conv2DGradFilter *>(value()) : nullptr;
  }
  const Conv2DGradInput *value_as_Conv2DGradInput() const {
    return value_type() == PrimitiveType_Conv2DGradInput ? static_cast<const Conv2DGradInput *>(value()) : nullptr;
  }
  const PoolingGrad *value_as_PoolingGrad() const {
    return value_type() == PrimitiveType_PoolingGrad ? static_cast<const PoolingGrad *>(value()) : nullptr;
  }
  const BNGradInput *value_as_BNGradInput() const {
    return value_type() == PrimitiveType_BNGradInput ? static_cast<const BNGradInput *>(value()) : nullptr;
  }
  const OptMomentum *value_as_OptMomentum() const {
    return value_type() == PrimitiveType_OptMomentum ? static_cast<const OptMomentum *>(value()) : nullptr;
  }
  const BiasGrad *value_as_BiasGrad() const {
    return value_type() == PrimitiveType_BiasGrad ? static_cast<const BiasGrad *>(value()) : nullptr;
  }
  const SoftmaxCrossEntropy *value_as_SoftmaxCrossEntropy() const {
    return value_type() == PrimitiveType_SoftmaxCrossEntropy ? static_cast<const SoftmaxCrossEntropy *>(value()) : nullptr;
  }
  const AddGrad *value_as_AddGrad() const {
    return value_type() == PrimitiveType_AddGrad ? static_cast<const AddGrad *>(value()) : nullptr;
  }
  const SubGrad *value_as_SubGrad() const {
    return value_type() == PrimitiveType_SubGrad ? static_cast<const SubGrad *>(value()) : nullptr;
  }
  const MulGrad *value_as_MulGrad() const {
    return value_type() == PrimitiveType_MulGrad ? static_cast<const MulGrad *>(value()) : nullptr;
  }
  const DivGrad *value_as_DivGrad() const {
    return value_type() == PrimitiveType_DivGrad ? static_cast<const DivGrad *>(value()) : nullptr;
  }
  const PowerGrad *value_as_PowerGrad() const {
    return value_type() == PrimitiveType_PowerGrad ? static_cast<const PowerGrad *>(value()) : nullptr;
  }
  const ActivationGrad *value_as_ActivationGrad() const {
    return value_type() == PrimitiveType_ActivationGrad ? static_cast<const ActivationGrad *>(value()) : nullptr;
  }
  const PriorBox *value_as_PriorBox() const {
    return value_type() == PrimitiveType_PriorBox ? static_cast<const PriorBox *>(value()) : nullptr;
  }
  const SpaceToBatchND *value_as_SpaceToBatchND() const {
    return value_type() == PrimitiveType_SpaceToBatchND ? static_cast<const SpaceToBatchND *>(value()) : nullptr;
  }
  const TopKV2 *value_as_TopKV2() const {
    return value_type() == PrimitiveType_TopKV2 ? static_cast<const TopKV2 *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPrimitiveType(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Concat *Primitive::value_as<Concat>() const {
  return value_as_Concat();
}

template<> inline const SoftMax *Primitive::value_as<SoftMax>() const {
  return value_as_SoftMax();
}

template<> inline const Activation *Primitive::value_as<Activation>() const {
  return value_as_Activation();
}

template<> inline const Conv2D *Primitive::value_as<Conv2D>() const {
  return value_as_Conv2D();
}

template<> inline const FusedBatchNorm *Primitive::value_as<FusedBatchNorm>() const {
  return value_as_FusedBatchNorm();
}

template<> inline const CaffeBatchNorm *Primitive::value_as<CaffeBatchNorm>() const {
  return value_as_CaffeBatchNorm();
}

template<> inline const BiasAdd *Primitive::value_as<BiasAdd>() const {
  return value_as_BiasAdd();
}

template<> inline const Pooling *Primitive::value_as<Pooling>() const {
  return value_as_Pooling();
}

template<> inline const DepthwiseConv2D *Primitive::value_as<DepthwiseConv2D>() const {
  return value_as_DepthwiseConv2D();
}

template<> inline const DeDepthwiseConv2D *Primitive::value_as<DeDepthwiseConv2D>() const {
  return value_as_DeDepthwiseConv2D();
}

template<> inline const Resize *Primitive::value_as<Resize>() const {
  return value_as_Resize();
}

template<> inline const DetectionPostProcess *Primitive::value_as<DetectionPostProcess>() const {
  return value_as_DetectionPostProcess();
}

template<> inline const FullConnection *Primitive::value_as<FullConnection>() const {
  return value_as_FullConnection();
}

template<> inline const Mean *Primitive::value_as<Mean>() const {
  return value_as_Mean();
}

template<> inline const DeConv2D *Primitive::value_as<DeConv2D>() const {
  return value_as_DeConv2D();
}

template<> inline const Scale *Primitive::value_as<Scale>() const {
  return value_as_Scale();
}

template<> inline const Reshape *Primitive::value_as<Reshape>() const {
  return value_as_Reshape();
}

template<> inline const Eltwise *Primitive::value_as<Eltwise>() const {
  return value_as_Eltwise();
}

template<> inline const NetOutput *Primitive::value_as<NetOutput>() const {
  return value_as_NetOutput();
}

template<> inline const Add *Primitive::value_as<Add>() const {
  return value_as_Add();
}

template<> inline const Sub *Primitive::value_as<Sub>() const {
  return value_as_Sub();
}

template<> inline const MatMul *Primitive::value_as<MatMul>() const {
  return value_as_MatMul();
}

template<> inline const StridedSlice *Primitive::value_as<StridedSlice>() const {
  return value_as_StridedSlice();
}

template<> inline const Power *Primitive::value_as<Power>() const {
  return value_as_Power();
}

template<> inline const Slice *Primitive::value_as<Slice>() const {
  return value_as_Slice();
}

template<> inline const Stack *Primitive::value_as<Stack>() const {
  return value_as_Stack();
}

template<> inline const Mul *Primitive::value_as<Mul>() const {
  return value_as_Mul();
}

template<> inline const RealDiv *Primitive::value_as<RealDiv>() const {
  return value_as_RealDiv();
}

template<> inline const Pad *Primitive::value_as<Pad>() const {
  return value_as_Pad();
}

template<> inline const Maximum *Primitive::value_as<Maximum>() const {
  return value_as_Maximum();
}

template<> inline const Minimum *Primitive::value_as<Minimum>() const {
  return value_as_Minimum();
}

template<> inline const CaffePReLU *Primitive::value_as<CaffePReLU>() const {
  return value_as_CaffePReLU();
}

template<> inline const LeakyReLU *Primitive::value_as<LeakyReLU>() const {
  return value_as_LeakyReLU();
}

template<> inline const ArgMax *Primitive::value_as<ArgMax>() const {
  return value_as_ArgMax();
}

template<> inline const ArgMin *Primitive::value_as<ArgMin>() const {
  return value_as_ArgMin();
}

template<> inline const Exp *Primitive::value_as<Exp>() const {
  return value_as_Exp();
}

template<> inline const Crop *Primitive::value_as<Crop>() const {
  return value_as_Crop();
}

template<> inline const Range *Primitive::value_as<Range>() const {
  return value_as_Range();
}

template<> inline const Rsqrt *Primitive::value_as<Rsqrt>() const {
  return value_as_Rsqrt();
}

template<> inline const ExpandDims *Primitive::value_as<ExpandDims>() const {
  return value_as_ExpandDims();
}

template<> inline const Tile *Primitive::value_as<Tile>() const {
  return value_as_Tile();
}

template<> inline const Cast *Primitive::value_as<Cast>() const {
  return value_as_Cast();
}

template<> inline const Shape *Primitive::value_as<Shape>() const {
  return value_as_Shape();
}

template<> inline const Nchw2Nhwc *Primitive::value_as<Nchw2Nhwc>() const {
  return value_as_Nchw2Nhwc();
}

template<> inline const Nhwc2Nchw *Primitive::value_as<Nhwc2Nchw>() const {
  return value_as_Nhwc2Nchw();
}

template<> inline const QuantDTypeCast *Primitive::value_as<QuantDTypeCast>() const {
  return value_as_QuantDTypeCast();
}

template<> inline const Split *Primitive::value_as<Split>() const {
  return value_as_Split();
}

template<> inline const Permute *Primitive::value_as<Permute>() const {
  return value_as_Permute();
}

template<> inline const FakeQuantWithMinMaxVars *Primitive::value_as<FakeQuantWithMinMaxVars>() const {
  return value_as_FakeQuantWithMinMaxVars();
}

template<> inline const Equal *Primitive::value_as<Equal>() const {
  return value_as_Equal();
}

template<> inline const Less *Primitive::value_as<Less>() const {
  return value_as_Less();
}

template<> inline const Greater *Primitive::value_as<Greater>() const {
  return value_as_Greater();
}

template<> inline const NotEqual *Primitive::value_as<NotEqual>() const {
  return value_as_NotEqual();
}

template<> inline const LessEqual *Primitive::value_as<LessEqual>() const {
  return value_as_LessEqual();
}

template<> inline const GreaterEqual *Primitive::value_as<GreaterEqual>() const {
  return value_as_GreaterEqual();
}

template<> inline const Min *Primitive::value_as<Min>() const {
  return value_as_Min();
}

template<> inline const Floor *Primitive::value_as<Floor>() const {
  return value_as_Floor();
}

template<> inline const Abs *Primitive::value_as<Abs>() const {
  return value_as_Abs();
}

template<> inline const Neg *Primitive::value_as<Neg>() const {
  return value_as_Neg();
}

template<> inline const Cos *Primitive::value_as<Cos>() const {
  return value_as_Cos();
}

template<> inline const Sin *Primitive::value_as<Sin>() const {
  return value_as_Sin();
}

template<> inline const Sqrt *Primitive::value_as<Sqrt>() const {
  return value_as_Sqrt();
}

template<> inline const Square *Primitive::value_as<Square>() const {
  return value_as_Square();
}

template<> inline const Constant *Primitive::value_as<Constant>() const {
  return value_as_Constant();
}

template<> inline const Log *Primitive::value_as<Log>() const {
  return value_as_Log();
}

template<> inline const Tan *Primitive::value_as<Tan>() const {
  return value_as_Tan();
}

template<> inline const Atan *Primitive::value_as<Atan>() const {
  return value_as_Atan();
}

template<> inline const Asin *Primitive::value_as<Asin>() const {
  return value_as_Asin();
}

template<> inline const Clip *Primitive::value_as<Clip>() const {
  return value_as_Clip();
}

template<> inline const Transpose *Primitive::value_as<Transpose>() const {
  return value_as_Transpose();
}

template<> inline const Squeeze *Primitive::value_as<Squeeze>() const {
  return value_as_Squeeze();
}

template<> inline const Unsqueeze *Primitive::value_as<Unsqueeze>() const {
  return value_as_Unsqueeze();
}

template<> inline const Upsample *Primitive::value_as<Upsample>() const {
  return value_as_Upsample();
}

template<> inline const Dropout *Primitive::value_as<Dropout>() const {
  return value_as_Dropout();
}

template<> inline const Broadcast *Primitive::value_as<Broadcast>() const {
  return value_as_Broadcast();
}

template<> inline const BroadcastTo *Primitive::value_as<BroadcastTo>() const {
  return value_as_BroadcastTo();
}

template<> inline const Lrn *Primitive::value_as<Lrn>() const {
  return value_as_Lrn();
}

template<> inline const Prelu *Primitive::value_as<Prelu>() const {
  return value_as_Prelu();
}

template<> inline const ZerosLike *Primitive::value_as<ZerosLike>() const {
  return value_as_ZerosLike();
}

template<> inline const TopK *Primitive::value_as<TopK>() const {
  return value_as_TopK();
}

template<> inline const SpaceToDepth *Primitive::value_as<SpaceToDepth>() const {
  return value_as_SpaceToDepth();
}

template<> inline const SpaceToBatch *Primitive::value_as<SpaceToBatch>() const {
  return value_as_SpaceToBatch();
}

template<> inline const SparseToDense *Primitive::value_as<SparseToDense>() const {
  return value_as_SparseToDense();
}

template<> inline const ReverseSequence *Primitive::value_as<ReverseSequence>() const {
  return value_as_ReverseSequence();
}

template<> inline const Rank *Primitive::value_as<Rank>() const {
  return value_as_Rank();
}

template<> inline const Gather *Primitive::value_as<Gather>() const {
  return value_as_Gather();
}

template<> inline const GatherNd *Primitive::value_as<GatherNd>() const {
  return value_as_GatherNd();
}

template<> inline const Fill *Primitive::value_as<Fill>() const {
  return value_as_Fill();
}

template<> inline const Elu *Primitive::value_as<Elu>() const {
  return value_as_Elu();
}

template<> inline const DepthToSpace *Primitive::value_as<DepthToSpace>() const {
  return value_as_DepthToSpace();
}

template<> inline const BatchToSpace *Primitive::value_as<BatchToSpace>() const {
  return value_as_BatchToSpace();
}

template<> inline const AddN *Primitive::value_as<AddN>() const {
  return value_as_AddN();
}

template<> inline const Ceil *Primitive::value_as<Ceil>() const {
  return value_as_Ceil();
}

template<> inline const EmbeddingLookup *Primitive::value_as<EmbeddingLookup>() const {
  return value_as_EmbeddingLookup();
}

template<> inline const EmbeddingLookupSparse *Primitive::value_as<EmbeddingLookupSparse>() const {
  return value_as_EmbeddingLookupSparse();
}

template<> inline const FloorDiv *Primitive::value_as<FloorDiv>() const {
  return value_as_FloorDiv();
}

template<> inline const FloorMod *Primitive::value_as<FloorMod>() const {
  return value_as_FloorMod();
}

template<> inline const L2Norm *Primitive::value_as<L2Norm>() const {
  return value_as_L2Norm();
}

template<> inline const LocalResponseNormalization *Primitive::value_as<LocalResponseNormalization>() const {
  return value_as_LocalResponseNormalization();
}

template<> inline const MatrixDiag *Primitive::value_as<MatrixDiag>() const {
  return value_as_MatrixDiag();
}

template<> inline const Reduce *Primitive::value_as<Reduce>() const {
  return value_as_Reduce();
}

template<> inline const Reverse *Primitive::value_as<Reverse>() const {
  return value_as_Reverse();
}

template<> inline const Round *Primitive::value_as<Round>() const {
  return value_as_Round();
}

template<> inline const Select *Primitive::value_as<Select>() const {
  return value_as_Select();
}

template<> inline const Scatter *Primitive::value_as<Scatter>() const {
  return value_as_Scatter();
}

template<> inline const ScatterND *Primitive::value_as<ScatterND>() const {
  return value_as_ScatterND();
}

template<> inline const Unique *Primitive::value_as<Unique>() const {
  return value_as_Unique();
}

template<> inline const Unstack *Primitive::value_as<Unstack>() const {
  return value_as_Unstack();
}

template<> inline const LogicalAnd *Primitive::value_as<LogicalAnd>() const {
  return value_as_LogicalAnd();
}

template<> inline const LogicalOr *Primitive::value_as<LogicalOr>() const {
  return value_as_LogicalOr();
}

template<> inline const LogicalXor *Primitive::value_as<LogicalXor>() const {
  return value_as_LogicalXor();
}

template<> inline const LogicalNot *Primitive::value_as<LogicalNot>() const {
  return value_as_LogicalNot();
}

template<> inline const OnnxInt8Quantize *Primitive::value_as<OnnxInt8Quantize>() const {
  return value_as_OnnxInt8Quantize();
}

template<> inline const OnnxInt8Dequantize *Primitive::value_as<OnnxInt8Dequantize>() const {
  return value_as_OnnxInt8Dequantize();
}

template<> inline const FakeQuantWithMinMax *Primitive::value_as<FakeQuantWithMinMax>() const {
  return value_as_FakeQuantWithMinMax();
}

template<> inline const FakeQuantWithMinMaxPerChannel *Primitive::value_as<FakeQuantWithMinMaxPerChannel>() const {
  return value_as_FakeQuantWithMinMaxPerChannel();
}

template<> inline const BatchNormFold *Primitive::value_as<BatchNormFold>() const {
  return value_as_BatchNormFold();
}

template<> inline const MulFold *Primitive::value_as<MulFold>() const {
  return value_as_MulFold();
}

template<> inline const AddFold *Primitive::value_as<AddFold>() const {
  return value_as_AddFold();
}

template<> inline const SquaredDifference *Primitive::value_as<SquaredDifference>() const {
  return value_as_SquaredDifference();
}

template<> inline const Flatten *Primitive::value_as<Flatten>() const {
  return value_as_Flatten();
}

template<> inline const TupleGetItem *Primitive::value_as<TupleGetItem>() const {
  return value_as_TupleGetItem();
}

template<> inline const Div *Primitive::value_as<Div>() const {
  return value_as_Div();
}

template<> inline const Where *Primitive::value_as<Where>() const {
  return value_as_Where();
}

template<> inline const OneHot *Primitive::value_as<OneHot>() const {
  return value_as_OneHot();
}

template<> inline const Lstm *Primitive::value_as<Lstm>() const {
  return value_as_Lstm();
}

template<> inline const Conv2DGradFilter *Primitive::value_as<Conv2DGradFilter>() const {
  return value_as_Conv2DGradFilter();
}

template<> inline const Conv2DGradInput *Primitive::value_as<Conv2DGradInput>() const {
  return value_as_Conv2DGradInput();
}

template<> inline const PoolingGrad *Primitive::value_as<PoolingGrad>() const {
  return value_as_PoolingGrad();
}

template<> inline const BNGradInput *Primitive::value_as<BNGradInput>() const {
  return value_as_BNGradInput();
}

template<> inline const OptMomentum *Primitive::value_as<OptMomentum>() const {
  return value_as_OptMomentum();
}

template<> inline const BiasGrad *Primitive::value_as<BiasGrad>() const {
  return value_as_BiasGrad();
}

template<> inline const SoftmaxCrossEntropy *Primitive::value_as<SoftmaxCrossEntropy>() const {
  return value_as_SoftmaxCrossEntropy();
}

template<> inline const AddGrad *Primitive::value_as<AddGrad>() const {
  return value_as_AddGrad();
}

template<> inline const SubGrad *Primitive::value_as<SubGrad>() const {
  return value_as_SubGrad();
}

template<> inline const MulGrad *Primitive::value_as<MulGrad>() const {
  return value_as_MulGrad();
}

template<> inline const DivGrad *Primitive::value_as<DivGrad>() const {
  return value_as_DivGrad();
}

template<> inline const PowerGrad *Primitive::value_as<PowerGrad>() const {
  return value_as_PowerGrad();
}

template<> inline const ActivationGrad *Primitive::value_as<ActivationGrad>() const {
  return value_as_ActivationGrad();
}

template<> inline const PriorBox *Primitive::value_as<PriorBox>() const {
  return value_as_PriorBox();
}

template<> inline const SpaceToBatchND *Primitive::value_as<SpaceToBatchND>() const {
  return value_as_SpaceToBatchND();
}

template<> inline const TopKV2 *Primitive::value_as<TopKV2>() const {
  return value_as_TopKV2();
}

struct PrimitiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(PrimitiveType value_type) {
    fbb_.AddElement<uint8_t>(Primitive::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Primitive::VT_VALUE, value);
  }
  explicit PrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrimitiveBuilder &operator=(const PrimitiveBuilder &);
  flatbuffers::Offset<Primitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Primitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<Primitive> CreatePrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    PrimitiveType value_type = PrimitiveType_NONE,
    flatbuffers::Offset<void> value = 0) {
  PrimitiveBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct CNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODETYPE = 6,
    VT_PRIMITIVE = 8,
    VT_INPUTINDEX = 10,
    VT_OUTPUTINDEX = 12,
    VT_QUANTTYPE = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  NodeType nodeType() const {
    return static_cast<NodeType>(GetField<int32_t>(VT_NODETYPE, 2));
  }
  const Primitive *primitive() const {
    return GetPointer<const Primitive *>(VT_PRIMITIVE);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  QuantType quantType() const {
    return static_cast<QuantType>(GetField<int32_t>(VT_QUANTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyOffset(verifier, VT_PRIMITIVE) &&
           verifier.VerifyTable(primitive()) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<int32_t>(verifier, VT_QUANTTYPE) &&
           verifier.EndTable();
  }
};

struct CNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CNode::VT_NAME, name);
  }
  void add_nodeType(NodeType nodeType) {
    fbb_.AddElement<int32_t>(CNode::VT_NODETYPE, static_cast<int32_t>(nodeType), 2);
  }
  void add_primitive(flatbuffers::Offset<Primitive> primitive) {
    fbb_.AddOffset(CNode::VT_PRIMITIVE, primitive);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(CNode::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(CNode::VT_OUTPUTINDEX, outputIndex);
  }
  void add_quantType(QuantType quantType) {
    fbb_.AddElement<int32_t>(CNode::VT_QUANTTYPE, static_cast<int32_t>(quantType), 0);
  }
  explicit CNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CNodeBuilder &operator=(const CNodeBuilder &);
  flatbuffers::Offset<CNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<CNode> CreateCNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    NodeType nodeType = NodeType_CNode,
    flatbuffers::Offset<Primitive> primitive = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    QuantType quantType = QuantType_QUANT_NONE) {
  CNodeBuilder builder_(_fbb);
  builder_.add_quantType(quantType);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_primitive(primitive);
  builder_.add_nodeType(nodeType);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CNode> CreateCNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    NodeType nodeType = NodeType_CNode,
    flatbuffers::Offset<Primitive> primitive = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    QuantType quantType = QuantType_QUANT_NONE) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  return mindspore::schema::CreateCNode(
      _fbb,
      name__,
      nodeType,
      primitive,
      inputIndex__,
      outputIndex__,
      quantType);
}

struct MetaGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FMKTYPE = 6,
    VT_INPUTINDEX = 8,
    VT_OUTPUTINDEX = 10,
    VT_MEMPOOLSIZE = 12,
    VT_NODES = 14,
    VT_ALLTENSORS = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t fmkType() const {
    return GetField<int32_t>(VT_FMKTYPE, 0);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  uint32_t mempoolSize() const {
    return GetField<uint32_t>(VT_MEMPOOLSIZE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CNode>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *allTensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *>(VT_ALLTENSORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_FMKTYPE) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<uint32_t>(verifier, VT_MEMPOOLSIZE) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_ALLTENSORS) &&
           verifier.VerifyVector(allTensors()) &&
           verifier.VerifyVectorOfTables(allTensors()) &&
           verifier.EndTable();
  }
};

struct MetaGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MetaGraph::VT_NAME, name);
  }
  void add_fmkType(int32_t fmkType) {
    fbb_.AddElement<int32_t>(MetaGraph::VT_FMKTYPE, fmkType, 0);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(MetaGraph::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(MetaGraph::VT_OUTPUTINDEX, outputIndex);
  }
  void add_mempoolSize(uint32_t mempoolSize) {
    fbb_.AddElement<uint32_t>(MetaGraph::VT_MEMPOOLSIZE, mempoolSize, 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CNode>>> nodes) {
    fbb_.AddOffset(MetaGraph::VT_NODES, nodes);
  }
  void add_allTensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> allTensors) {
    fbb_.AddOffset(MetaGraph::VT_ALLTENSORS, allTensors);
  }
  explicit MetaGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetaGraphBuilder &operator=(const MetaGraphBuilder &);
  flatbuffers::Offset<MetaGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetaGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t fmkType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    uint32_t mempoolSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CNode>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> allTensors = 0) {
  MetaGraphBuilder builder_(_fbb);
  builder_.add_allTensors(allTensors);
  builder_.add_nodes(nodes);
  builder_.add_mempoolSize(mempoolSize);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_fmkType(fmkType);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetaGraph> CreateMetaGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t fmkType = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    uint32_t mempoolSize = 0,
    const std::vector<flatbuffers::Offset<CNode>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<Tensor>> *allTensors = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<CNode>>(*nodes) : 0;
  auto allTensors__ = allTensors ? _fbb.CreateVector<flatbuffers::Offset<Tensor>>(*allTensors) : 0;
  return mindspore::schema::CreateMetaGraph(
      _fbb,
      name__,
      fmkType,
      inputIndex__,
      outputIndex__,
      mempoolSize,
      nodes__,
      allTensors__);
}

inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
  switch (type) {
    case PrimitiveType_NONE: {
      return true;
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftMax: {
      auto ptr = reinterpret_cast<const SoftMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2D: {
      auto ptr = reinterpret_cast<const Conv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const FusedBatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CaffeBatchNorm: {
      auto ptr = reinterpret_cast<const CaffeBatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const BiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pooling: {
      auto ptr = reinterpret_cast<const Pooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthwiseConv2D: {
      auto ptr = reinterpret_cast<const DepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      auto ptr = reinterpret_cast<const DeDepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const DetectionPostProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const FullConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mean: {
      auto ptr = reinterpret_cast<const Mean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2D: {
      auto ptr = reinterpret_cast<const DeConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scale: {
      auto ptr = reinterpret_cast<const Scale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NetOutput: {
      auto ptr = reinterpret_cast<const NetOutput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Add: {
      auto ptr = reinterpret_cast<const Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sub: {
      auto ptr = reinterpret_cast<const Sub *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatMul: {
      auto ptr = reinterpret_cast<const MatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const StridedSlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Power: {
      auto ptr = reinterpret_cast<const Power *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Slice: {
      auto ptr = reinterpret_cast<const Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mul: {
      auto ptr = reinterpret_cast<const Mul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const RealDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pad: {
      auto ptr = reinterpret_cast<const Pad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CaffePReLU: {
      auto ptr = reinterpret_cast<const CaffePReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LeakyReLU: {
      auto ptr = reinterpret_cast<const LeakyReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMax: {
      auto ptr = reinterpret_cast<const ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMin: {
      auto ptr = reinterpret_cast<const ArgMin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Exp: {
      auto ptr = reinterpret_cast<const Exp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const Rsqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tile: {
      auto ptr = reinterpret_cast<const Tile *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const Shape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nchw2Nhwc: {
      auto ptr = reinterpret_cast<const Nchw2Nhwc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nhwc2Nchw: {
      auto ptr = reinterpret_cast<const Nhwc2Nchw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const QuantDTypeCast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Permute: {
      auto ptr = reinterpret_cast<const Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const FakeQuantWithMinMaxVars *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Min: {
      auto ptr = reinterpret_cast<const Min *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const Floor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const Square *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Constant: {
      auto ptr = reinterpret_cast<const Constant *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tan: {
      auto ptr = reinterpret_cast<const Tan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Atan: {
      auto ptr = reinterpret_cast<const Atan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Asin: {
      auto ptr = reinterpret_cast<const Asin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const Clip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const Unsqueeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Upsample: {
      auto ptr = reinterpret_cast<const Upsample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const Dropout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Broadcast: {
      auto ptr = reinterpret_cast<const Broadcast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const BroadcastTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lrn: {
      auto ptr = reinterpret_cast<const Lrn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Prelu: {
      auto ptr = reinterpret_cast<const Prelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const ZerosLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TopK: {
      auto ptr = reinterpret_cast<const TopK *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const SpaceToDepth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const SpaceToBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const SparseToDense *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const ReverseSequence *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const GatherNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const Elu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const DepthToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const BatchToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const AddN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const Ceil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookup: {
      auto ptr = reinterpret_cast<const EmbeddingLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      auto ptr = reinterpret_cast<const EmbeddingLookupSparse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const FloorDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const FloorMod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_L2Norm: {
      auto ptr = reinterpret_cast<const L2Norm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LocalResponseNormalization: {
      auto ptr = reinterpret_cast<const LocalResponseNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatrixDiag: {
      auto ptr = reinterpret_cast<const MatrixDiag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reduce: {
      auto ptr = reinterpret_cast<const Reduce *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reverse: {
      auto ptr = reinterpret_cast<const Reverse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const Round *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const Select *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scatter: {
      auto ptr = reinterpret_cast<const Scatter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterND: {
      auto ptr = reinterpret_cast<const ScatterND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const Unique *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const LogicalAnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const LogicalOr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalXor: {
      auto ptr = reinterpret_cast<const LogicalXor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const LogicalNot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Quantize: {
      auto ptr = reinterpret_cast<const OnnxInt8Quantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      auto ptr = reinterpret_cast<const OnnxInt8Dequantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      auto ptr = reinterpret_cast<const FakeQuantWithMinMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      auto ptr = reinterpret_cast<const FakeQuantWithMinMaxPerChannel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNormFold: {
      auto ptr = reinterpret_cast<const BatchNormFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulFold: {
      auto ptr = reinterpret_cast<const MulFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddFold: {
      auto ptr = reinterpret_cast<const AddFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const SquaredDifference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TupleGetItem: {
      auto ptr = reinterpret_cast<const TupleGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Div: {
      auto ptr = reinterpret_cast<const Div *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const OneHot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lstm: {
      auto ptr = reinterpret_cast<const Lstm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradFilter: {
      auto ptr = reinterpret_cast<const Conv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradInput: {
      auto ptr = reinterpret_cast<const Conv2DGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PoolingGrad: {
      auto ptr = reinterpret_cast<const PoolingGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BNGradInput: {
      auto ptr = reinterpret_cast<const BNGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OptMomentum: {
      auto ptr = reinterpret_cast<const OptMomentum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasGrad: {
      auto ptr = reinterpret_cast<const BiasGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const SoftmaxCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const AddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const SubGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const MulGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const DivGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const PowerGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const ActivationGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const SpaceToBatchND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TopKV2: {
      auto ptr = reinterpret_cast<const TopKV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPrimitiveType(
        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
      return false;
    }
  }
  return true;
}

inline const mindspore::schema::MetaGraph *GetMetaGraph(const void *buf) {
  return flatbuffers::GetRoot<mindspore::schema::MetaGraph>(buf);
}

inline const mindspore::schema::MetaGraph *GetSizePrefixedMetaGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::MetaGraph>(buf);
}

inline bool VerifyMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mindspore::schema::MetaGraph>(nullptr);
}

inline bool VerifySizePrefixedMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mindspore::schema::MetaGraph>(nullptr);
}

inline void FinishMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
