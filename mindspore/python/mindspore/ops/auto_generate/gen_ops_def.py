# Copyright 2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================

"""Operators definition generated by gen_ops.py, includes functions."""

from .gen_ops_prim import *
from .pyboost_inner_prim import *
from mindspore.ops.operations.manually_defined.ops_def import *
from mindspore.ops._primitive_cache import _get_cache_prim


def abs(input):
    r"""
    Returns absolute value of a tensor element-wise.

    .. math::

        out_i = |input_i|

    Args:
        input (Tensor): The input tensor. The shape of tensor is
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.

    Returns:
        Tensor, has the same shape as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([-1.0, 1.0, 0.0]), mindspore.float32)
        >>> output = ops.abs(input)
        >>> print(output)
        [1. 1. 0.]
    """
    return abs_op(input)


def acos(input):
    r"""
    Computes arccosine of input tensors element-wise.

    .. math::

        out_i = \cos^{-1}(input_i)

    Args:
        input (Tensor): The shape of tensor is
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.

    Returns:
        Tensor, has the same shape and dtype as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not float16, float32 or float64, complex64, complex128.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.74, 0.04, 0.30, 0.56]), mindspore.float32)
        >>> output = ops.acos(input)
        >>> print(output)
        [0.737726  1.5307857 1.2661036 0.9764105]
    """
    return acos_op(input)


def acosh(input):
    r"""
    Computes inverse hyperbolic cosine of the inputs element-wise.

    .. math::

        out_i = \cosh^{-1}(input_i)

    .. warning::
        Given an input tensor input, the function computes inverse hyperbolic cosine of every element.
        Input range is [1, inf].

    Args:
        input (Tensor): The input tensor of inverse hyperbolic cosine function.

    Returns:
        Tensor, has the same shape and type as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1.0, 1.5, 3.0, 100.0]), mindspore.float32)
        >>> output = ops.acosh(input)
        >>> print(output)
        [0.        0.9624237 1.7627472 5.298292 ]
    """
    return acosh_op(input)


def add_ext(input, other, alpha=1):
    r"""
    Adds scaled other value to input Tensor.

    .. math::

        out_{i} = input_{i} + alpha \times other_{i}

    Note:
        - When the two inputs have different shapes,
          they must be able to broadcast to a common shape.
        - The two inputs and alpha comply with the implicit type conversion rules to make the data types
          consistent.

    Args:
        input (Union[Tensor, number.Number, bool]): The first input is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.
        other (Union[Tensor, number.Number, bool]): The second input, is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.
        alpha (number.Number): A scaling factor applied to `other`, default 1.

    Returns:
        Tensor, the shape is the same as the one of the input `input`, `other` after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs and alpha.

    Raises:
        TypeError: If the type of `input`, `other`, or `alpha` is not one of the following: Tensor, number.Number, bool.
        TypeError: If `alpha` is of type float but `input` and `other` are not of type float.
        TypeError: If `alpha` is of type bool but `input` and `other` are not of type bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> import mindspore
        >>> from mindspore import Tensor
        >>> from mindspore.ops.extend import add
        >>> x = Tensor(1, mindspore.int32)
        >>> y = Tensor(np.array([4, 5, 6]).astype(np.float32))
        >>> alpha = 0.5
        >>> output = add(x, y, alpha)
        >>> print(output)
        [3. 3.5 4.]
        >>> # the data type of x is int32, the data type of y is float32,
        >>> # alpha is a float, and the output is the data format of higher precision float32.
        >>> print(output.dtype)
        Float32
    """
    return add_ext_op(input, other, alpha)


def add(input, other):
    r"""
    Adds other value to input Tensor.

    .. math::

        out_{i} = input_{i} + other_{i}

    Note:
        - When the two inputs have different shapes,
          they must be able to broadcast to a common shape.
        - The two inputs can not be bool type at the same time,
          [True, Tensor(True, bool\_), Tensor(np.array([True]), bool\_)] are all considered bool type.
        - The two inputs comply with the implicit type conversion rules to make the data types
          consistent.
        - When the input is a Tensor, the dimension should be greater than or equal to 1.

    Args:
        input (Union[Tensor, number.Number, bool]): The first input is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.
        other (Union[Tensor, number.Number, bool]): The second input, is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.

    Returns:
        Tensor, the shape is the same as the one of the input `input` , `other` after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs.

    Raises:
        TypeError: If `input` and `other` is not one of the following: Tensor, number.Number, bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> # case 1: x and y are both Tensor.
        >>> x = Tensor(np.array([1, 2, 3]).astype(np.float32))
        >>> y = Tensor(np.array([4, 5, 6]).astype(np.float32))
        >>> output = ops.add(x, y)
        >>> print(output)
        [5. 7. 9.]
        >>> # case 2: x is a scalar and y is a Tensor
        >>> x = Tensor(1, mindspore.int32)
        >>> y = Tensor(np.array([4, 5, 6]).astype(np.float32))
        >>> output = ops.add(x, y)
        >>> print(output)
        [5. 6. 7.]
        >>> # the data type of x is int32, the data type of y is float32,
        >>> # and the output is the data format of higher precision float32.
        >>> print(output.dtype)
        Float32
    """
    return add_op(input, other)


def addn(x):
    r"""
    Computes addition of all input tensors element-wise.
    All input tensors must have the same shape.

    Args:
      x (Union(tuple[Tensor], list[Tensor])): 
        A tuple or list composed of Tensor.

    Returns:
      Tensor, has the same shape and dtype as each Tensor of x.

    Raises:
      TypeError: If x is neither tuple nor list.
      TypeError:
        If there are Tensors with different shapes in x.

    Supported Platforms:
      ``Ascend`` ``GPU`` ``CPU``

    Examples:
      import mindspore
      import numpy as np
      from mindspore import Tensor, ops
      x = Tensor(np.array([1, 2, 3]), mindspore.float32)
      y = Tensor(np.array([4, 5, 6]), mindspore.float32)
      output = ops.addn([x, y, x, y])
      print(output)
    """
    return addn_op(x)


def angle(input):
    r"""
    Returns the element-wise argument of a complex tensor.
    The elements in input are considered to be complex numbers of the form a+bj, where a is the real part and b
    is the imaginary part. The argument returned by this function is of the form :math:`atan2(b, a)`.

    Args:
      input (Tensor):
        The input tensor. types: complex64, complex128.

    Returns:
      Tensor, has the float32 or float64 type and the same shape as input.

    Raises:
      TypeError: If `input` is not a Tensor.
      TypeError:
        If the dtype of `input` is not one of: complex64, complex128.

    Supported Platforms:
      ``Ascend`` ``GPU`` ``CPU``

    Examples:
      >>> import mindspore
      >>> from mindspore import Tensor, ops
      >>> input = Tensor([-1.5 + 7.8j, 3 + 5.75j], mindspore.complex64)
      >>> output = ops.angle(input)
      >>> print(output)
      [1.7607845 1.0899091]
    """
    return angle_op(input)


def apply_rotary_pos_emb_(query, key, cos, sin, position_ids, cos_format=0):
    r"""
    
    """
    apply_rotary_pos_emb_op = _get_cache_prim(ApplyRotaryPosEmb)(cos_format)
    return apply_rotary_pos_emb_op(query, key, cos, sin, position_ids)


def argmax(input, dim=None, keepdim=False):
    r"""
    Return the indices of the maximum values of a tensor across a dimension.

    Args:
        input (Tensor): Input tensor.
        dim (Union[int, None], optional): The dimension to reduce. If `dim` is ``None`` , the indices of the maximum
            value within the flattened input will be returned. Default: ``None`` .
        keepdim (bool, optional): Whether the output tensor retains the specified
            dimension. Ignored if `dim` is None. Default: ``False`` .

    Returns:
        Tensor, indices of the maximum values across a dimension.

    Raises:
        TypeError: If `keepdim` is not bool.
        ValueError: If `dim` is out of range.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[1, 20, 5], [67, 8, 9], [130, 24, 15]]).astype(np.float32))
        >>> output = ops.argmax(x, dim=-1)
        >>> print(output)
        [1 0 0]
    """
    return argmax_ext_op(input, dim, keepdim)


def asin(input):
    r"""
    Computes arcsine of input tensors element-wise.

    .. math::

        out_i = \sin^{-1}(input_i)

    Args:
        input (Tensor): The shape of tensor is
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.

    Returns:
        Tensor, has the same shape and dtype as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not float16, float32, float64, complex64, complex128.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.74, 0.04, 0.30, 0.56]), mindspore.float32)
        >>> output = ops.asin(input)
        >>> print(output)
        [0.8330704  0.04001067  0.30469266  0.5943858 ]
    """
    return asin_op(input)


def asinh(input):
    r"""
    Computes inverse hyperbolic sine of the input element-wise.

    .. math::

        out_i = \sinh^{-1}(input_i)

    Args:
        input (Tensor): The input tensor of inverse hyperbolic sine function.

    Returns:
        Tensor, has the same shape and type as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([-5.0, 1.5, 3.0, 100.0]), mindspore.float32)
        >>> output = ops.asinh(input)
        >>> print(output)
        [-2.3124382  1.1947632  1.8184465  5.298342 ]
    """
    return asinh_op(input)


def assign_add(variable, value):
    r"""
    Updates a `Parameter` by adding a value to it.

    Args of `variable` and `value` comply with the implicit type conversion rules to make the data types consistent.
    If they have different data types, the lower priority data type will be converted to
    the relatively highest priority data type.
    If `value` is a number, the number is automatically converted to Tensor,
    and the data type is consistent with the Tensor data type involved in the operation.

    Note:
        Since `variable` is a data type Parameter, the data type cannot be changed,
        so only the type of `value` is allowed to be promoted to the type of `variable`.
        And the conversion type supported by different devices will be different,
        it is recommended to use the same data type when using this operator.

    Args:
        variable (Parameter): The `Parameter`.
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.
        value (Tensor): The value to be added to the `variable`.
            It must have the same shape as `variable`.
            it is recommended to use the same data type when using this operator.

    Returns:
        Tensor, has the same data type and shape as original `variable`.

    Raises:
        TypeError: If `value` is neither Number nor Tensor.
        RuntimeError: If the data type of `variable` and `value` conversion of Parameter
                    is required when data type conversion of Parameter is not supported.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> from mindspore.common.initializer import initializer
        >>> variable = mindspore.Parameter(initializer(1, [1], mindspore.int32), name="global_step")
        >>> value = Tensor(np.ones([1]).astype(np.int32) * 100)
        >>> ops.assign_add(variable, value)
        >>> print(variable.asnumpy())
        [101]
    """
    return assign_add_op(variable, value)


def assign(variable, value):
    r"""
    Assigns `Parameter` with a value.

    Args of `variable` and `value` comply with the implicit type conversion rules to make the data types consistent.
    If they have different data types, the lower priority data type will be converted to
    the relatively highest priority data type.

    Args:
        variable (Parameter): The `Parameter`. :math:`(N,*)` where :math:`*` means,
            any number of additional dimensions.
        value (Tensor): The value to be assigned, has the same shape with `variable`.

    Returns:
        Tensor, has the same data type and shape as original `variable`.

    Raises:
        TypeError: If `variable` is not a Parameter.
        TypeError: If `value` is not a Tensor.
        RuntimeError: If the data type of `variable` and `value` conversion of Parameter
                      is required when data type conversion of Parameter is not supported.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> value = Tensor([2.0], mindspore.float32)
        >>> variable = mindspore.Parameter(Tensor([1.0], mindspore.float32), name="variable")
        >>> ops.assign(variable, value)
        >>> print(variable.asnumpy())
        [2.]
    """
    return assign_op(variable, value)


def atan2(input, other):
    r"""
    Returns arctangent of input/other element-wise.

    It returns :math:`\theta\ \in\ [-\pi, \pi]`
    such that :math:`input = r*\sin(\theta), other = r*\cos(\theta)`, where :math:`r = \sqrt{input^2 + other^2}`.

    Note:
        - Arg `input` and `other` comply with the implicit type conversion rules to make the data types consistent.
          If they have different data types, the lower precision data type will be converted to relatively the
          highest precision data type.

    Args:
        input (Tensor, Number.number): The input tensor or scalar.
        other (Tensor, Number.number): The input tensor or scalar. It has the same shape with `input` or
            its shape is able to broadcast with `input`.

    Returns:
        Tensor, the shape is the same as the one after broadcasting, and the data type is same as `input`.

    Raises:
        TypeError: If `input` or `other` is not a Tensor or scalar.
        RuntimeError: If the data type of `input` and `other` conversion of Parameter is required
                    when data type conversion of Parameter is not supported.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0, 1]), mindspore.float32)
        >>> other = Tensor(np.array([1, 1]), mindspore.float32)
        >>> output = ops.atan2(input, other)
        >>> print(output)
        [0.        0.7853982]
    """
    return atan2_op(input, other)


def atan(input):
    r"""
    Computes the trigonometric inverse tangent of the input element-wise.

    .. math::

        out_i = \tan^{-1}(input_i)

    Args:
        input (Tensor): The shape of tensor is
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.
            Supported dtypes: 

            - Ascend: float16, float32.
            - GPU/CPU: float16, float32, float64, complex64 or complex128.

    Returns:
        A Tensor, has the same type as the input.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not float16, float32, float64, complex64 or complex128.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1.0, 0.0]), mindspore.float32)
        >>> output = ops.atan(input)
        >>> print(output)
        [0.7853982 0.       ]
    """
    return atan_op(input)


def atanh(input):
    r"""
    Computes inverse hyperbolic tangent of the input element-wise.

    .. math::

        out_i = \tanh^{-1}(input_{i})

    Args:
        input (Tensor): The shape of tensor is
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.
            The data type should be one of the following types: float16, float32.

    Returns:
        A Tensor, has the same type as the input.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not float16 or float32.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0, -0.5]), mindspore.float32)
        >>> output = ops.atanh(input)
        >>> print(output)
        [ 0.         -0.54930615]
    """
    return atanh_op(input)


def bmm_ext(input, mat2):
    r"""
    Performs batch matrix-matrix multiplication of two three-dimensional tensors.

    .. math::
        \text{output}[b, i, j] = \text{input}[b, i, k] @ \text{mat2}[b, k, j]

    Args:
        input (Tensor): The first batch of matrices to be multiplied. Must be a three-dimensional tensor.
        mat2 (Tensor): The second batch of matrices to be multiplied. Must be a three-dimensional tensor.

    Returns:
        Tensor, the output tensor of shape `(b, n, p)`, where each matrix is the product of the corresponding matrices in the input batches.

    Raises:
        TypeError: If `input` or `mat2` is not three-dimensional tensors.
        ValueError: If the length of the third dimension of `input` is not equal to the length of the second dimension of `mat2`.
        ValueError: If the batch size of the inputs do not match.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor
        >>> from mindspore.ops.extend import bmm
        >>> a = Tensor(np.ones(shape=[2, 3, 4]), mindspore.float32)
        >>> b = Tensor(np.ones(shape=[2, 4, 5]), mindspore.float32)
        >>> output = bmm(a, b)
        >>> print(output.shape)
        (2, 3, 5)
    """
    return bmm_ext_op(input, mat2)


def broadcast_to(input, shape):
    r"""
    Broadcasts input tensor to a given shape. The dim of input shape must be smaller
    than or equal to that of target shape. Suppose input shape is :math:`(x_1, x_2, ..., x_m)`,
    target shape is :math:`(*, y_1, y_2, ..., y_m)`, where :math:`*` means any additional dimension.
    The broadcast rules are as follows:

    Compare the value of :math:`x_m` and :math:`y_m`, :math:`x_{m-1}` and :math:`y_{m-1}`, ...,
    :math:`x_1` and :math:`y_1` consecutively and
    decide whether these shapes are broadcastable and what the broadcast result is.

    - If the value pairs at a specific dim are equal, then that value goes right into that dim of output shape.
      With an input shape :math:`(2, 3)`, target shape :math:`(2, 3)` , the inferred output shape is :math:`(2, 3)`.

    - If the value pairs are unequal, there are three cases:

      - Case 1: If the value of the target shape in the dimension is -1, the value of the
        output shape in the dimension is the value of the corresponding input shape in the dimension.
        With an input shape :math:`(3, 3)`, target
        shape :math:`(-1, 3)`, the output shape is :math:`(3, 3)`.

      - Case 2: If the value of target shape in the dimension is not -1, but the corresponding
        value in the input shape is 1, then the corresponding value of the output shape
        is that of the target shape. With an input shape :math:`(1, 3)`, target
        shape :math:`(8, 3)`, the output shape is :math:`(8, 3)`.

      - Case 3: If the corresponding values of the two shapes do not satisfy the above cases,
        it means that broadcasting from the input shape to the target shape is not supported.

    So far we got the last m dims of the outshape, now focus on the first :math:`*` dims, there are
    two cases:

    - If the first :math:`*` dims of output shape does not have -1 in it, then fill the input
      shape with ones until their length are the same, and then refer to
      Case 2 mentioned above to calculate the output shape. With target shape :math:`(3, 1, 4, 1, 5, 9)`,
      input shape :math:`(1, 5, 9)`, the filled input shape will be :math:`(1, 1, 1, 1, 5, 9)` and thus the
      output shape is :math:`(3, 1, 4, 1, 5, 9)`.

    - If the first :math:`*` dims of output shape have -1 in it, it implies this -1 is corresponding to
      a non-existing dim so they're not broadcastable. With target shape :math:`(3, -1, 4, 1, 5, 9)`,
      input shape :math:`(1, 5, 9)`, instead of operating the dim-filling process first, it raises errors directly.

    Args:
        input (Tensor): The input Tensor.
        shape (tuple): The target shape to broadcast. Can be fully specified, or have -1 in one position
                      where it will be substituted by the input tensor's shape in that position, see example.

    Returns:
        Tensor, with the given `shape` and the same data type as `input`.

    Raises:
        TypeError: If `shape` is not a tuple.
        ValueError: If the target and input shapes are incompatible, or if a - 1 in the target shape is in an invalid
                    location.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> shape = (2, 3)
        >>> x = Tensor(np.array([1, 2, 3]).astype(np.float32))
        >>> output = ops.broadcast_to(x, shape)
        >>> print(output)
        [[1. 2. 3.]
        [1. 2. 3.]]
        >>> shape = (-1, 2)
        >>> x = Tensor(np.array([[1], [2]]).astype(np.float32))
        >>> output = ops.broadcast_to(x, shape)
        >>> print(output)
        [[1. 1.]
        [2. 2.]]
    """
    return broadcast_to_impl(input, shape)


cast_op = Cast()


def cast(input_x, dtype):
    r"""
    Returns a tensor with the new specified data type.

    Note:
        When converting complex numbers to boolean type, the imaginary part of the complex number is not
        taken into account. As long as the real part is non-zero, it returns True; otherwise, it returns False.

    Inputs:
        - **input_x** (Union[Tensor, Number]) - The shape of tensor is :math:`(x_1, x_2, ..., x_R)`.
          The tensor to be cast.
        - **type** (dtype.Number) - The valid data type of the output tensor. Only constant value is allowed.

    Outputs:
        Tensor, the shape of tensor is the same as `input_x`, :math:`(x_1, x_2, ..., x_R)`.

    Raises:
        TypeError: If `input_x` is neither Tensor nor Number.
        TypeError: If `type` is not a Number.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input_np = np.random.randn(2, 3, 4, 5).astype(np.float32)
        >>> input_x = Tensor(input_np)
        >>> type_dst = mindspore.int32
        >>> cast = ops.Cast()
        >>> output = cast(input_x, type_dst)
        >>> print(output.dtype)
        Int32
        >>> print(output.shape)
        (2, 3, 4, 5)
    """
    return cast_op(input_x, dtype)


def ceil(input):
    r"""
    Rounds a tensor up to the closest integer element-wise.

    .. math::
        out_i = \lceil x_i \rceil = \lfloor x_i \rfloor + 1

    Args:
        input (Tensor): the input of Ceil.
            Supported dtypes: 

            - Ascend: float16, float32, float64 or bfloat16.
            - GPU/CPU: float16, float32, float64.

    Returns:
        Tensor, has the same shape as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not float16, float32, float64 or bfloat16.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1.1, 2.5, -1.5]), mindspore.float32)
        >>> output = ops.ceil(input)
        >>> print(output)
        [ 2.  3. -1.]
        >>> input = Tensor(2.1, mindspore.float32)
        >>> output = ops.ceil(input)
        >>> print(output)
        3.0
    """
    return ceil_op(input)


def celu(x, alpha=1.0):
    r"""
    celu activation function, computes celu (Continuously differentiable exponential
    linear units) of input tensors element-wise. The formula is defined as follows:

    .. math::

        \text{CeLU}(x) = \max(0,x) + \min(0, \alpha * (\exp(x/\alpha) - 1))

    For more details, please refer to `celu <https://arxiv.org/abs/1704.07483>`_.

    .. warning::
        This is an experimental API that is subject to change or deletion.

    CELU Activation Function Graph:

    .. image:: ../images/CELU.png
        :align: center

    Args:
        x (Tensor): The input of celu with data type of float16 or float32.
        alpha (float, optional): The :math:`\alpha` value for the Celu formulation. Default: 1.0

    Returns:
        Tensor, has the same data type and shape as the input.

    Raises:
        TypeError: If `alpha` is not a float.
        TypeError: If `x` is not a Tensor.
        TypeError: If dtype of `x` is neither float16 nor float32.
        ValueError: If `alpha` has the value of 0.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([-2.0, -1.0, 1.0, 2.0]), mindspore.float32)
        >>> output = ops.celu(x, alpha=1.0)
        >>> print(output)
        [-0.86466473 -0.63212055  1.          2.        ]
    """
    celu_op = _get_cache_prim(CeLU)(alpha)
    return celu_op(x)


def clamp_scalar(input, min=None, max=None):
    r"""
    Clamps tensor values between the specified minimum value and maximum value.

    Limits the value of :math:`input` to a range, whose lower limit is `min` and upper limit is `max` .

    .. math::

        out_i= \left\{
        \begin{array}{align}
            max & \text{ if } input_i\ge max \\
            input_i & \text{ if } min \lt input_i \lt max \\
            min & \text{ if } input_i \le min \\
        \end{array}\right

    Note:
        - `min` and `max` cannot be None at the same time;
        - When `min` is None and `max` is not None, the elements in Tensor larger than `max` will become `max`;
        - When `min` is not None and `max` is None, the elements in Tensor smaller than `min` will become `min`;
        - If `min` is greater than `max`, the value of all elements in Tensor will be set to `max`;
        - The data type of `input`, `min` and `max` should support implicit type conversion and cannot be bool type.

    Args:
          input (Tensor): Input data, which type is Tensor. Tensors of arbitrary dimensions are supported.
          min (Union(float, int), optional): The minimum value. Default: ``None`` .
          max (Union(float, int), optional): The maximum value. Default: ``None`` .

    Returns:
          Tensor, a clipped Tensor.
          The data type and shape are the same as input.

    Raises:
          ValueError: If both `min` and `max` are None.
          TypeError: If the type of `input` is not Tensor.
          TypeError: If the type of `min` is not in None, float or int.
          TypeError: If the type of `max` is not in None, float or int.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> # case 1: the data type of input is number
        >>> import mindspore
        >>> from mindspore import Tensor
        >>> from mindspore.ops.auto_generate import clamp_scalar
        >>> import numpy as np
        >>> min_value = 5
        >>> max_value = 20
        >>> input = Tensor(np.array([[1., 25., 5., 7.], [4., 11., 6., 21.]]), mindspore.float32)
        >>> output = clamp_scalar(input, min_value, max_value)
        >>> print(output)
        [[ 5. 20.  5.  7.]
        [ 5. 11.  6. 20.]]
    """
    return clamp_scalar_op(input, min, max)


def clamp_tensor(input, min=None, max=None):
    r"""
    Clamps tensor values between the specified minimum value and maximum value.

    Limits the value of :math:`input` to a range, whose lower limit is `min` and upper limit is `max` .

    .. math::

        out_i= \left\{
        \begin{array}{align}
            max & \text{ if } input_i\ge max \\
            input_i & \text{ if } min \lt input_i \lt max \\
            min & \text{ if } input_i \le min \\
        \end{array}\right

    Note:
        - `min` and `max` cannot be None at the same time;
        - When `min` is None and `max` is not None, the elements in Tensor larger than `max` will become `max`;
        - When `min` is not None and `max` is None, the elements in Tensor smaller than `min` will become `min`;
        - If `min` is greater than `max`, the value of all elements in Tensor will be set to `max`;
        - The data type of `input`, `min` and `max` should support implicit type conversion and cannot be bool type.

    Args:
          input (Tensor): Input data, which type is Tensor. Tensors of arbitrary dimensions are supported.
          min (Tensor, optional): The minimum value. Default: ``None`` .
          max (Tensor, optional): The maximum value. Default: ``None`` .

    Returns:
          Tensor, a clipped Tensor.
          The data type and shape are the same as input.

    Raises:
          ValueError: If both `min` and `max` are None.
          TypeError: If the type of `input` is not Tensor.
          TypeError: If the type of `min` is not in None, Tensor.
          TypeError: If the type of `max` is not in None, Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> # case 1: the data type of input is Tensor
        >>> import mindspore
        >>> from mindspore import Tensor
        >>> from mindspore.ops.auto_generate import clamp_tensor
        >>> import numpy as np
        >>> min_value = Tensor(5, mindspore.float32)
        >>> max_value = Tensor(20, mindspore.float32)
        >>> input = Tensor(np.array([[1., 25., 5., 7.], [4., 11., 6., 21.]]), mindspore.float32)
        >>> output = clamp_tensor(input, min_value, max_value)
        >>> print(output)
        [[ 5. 20.  5.  7.]
        [ 5. 11.  6. 20.]]
    """
    return clamp_tensor_op(input, min, max)


def cat(tensors, axis=0):
    r"""
    Connect input tensors along with the given axis.

    The input data is a tuple or a list of tensors. These tensors have the same rank :math:`R`.
    Set the given axis as :math:`m`, and :math:`0 \le m < R`. Set the number of input tensors as :math:`N`.
    For the :math:`i`-th tensor :math:`t_i`, it has the shape of :math:`(x_1, x_2, ..., x_{mi}, ..., x_R)`.
    :math:`x_{mi}` is the :math:`m`-th dimension of the :math:`t_i`. Then, the shape of the output tensor is

    .. math::

        (x_1, x_2, ..., \sum_{i=1}^Nx_{mi}, ..., x_R)

    Args:
        tensors (Union[tuple, list]): A tuple or a list of input tensors.
            Suppose there are two tensors in this tuple or list, namely t1 and t2.
            To perform `concat` in the axis 0 direction, except for the :math:`0`-th axis,
            all other dimensions should be equal, that is,
            :math:`t1.shape[1] = t2.shape[1], t1.shape[2] = t2.shape[2], ..., t1.shape[R-1] = t2.shape[R-1]`,
            where :math:`R` represents the rank of tensor.
        axis (int): The specified axis, whose value is in range :math:`[-R, R)`. Default: ``0`` .

    Returns:
        Tensor, the shape is :math:`(x_1, x_2, ..., \sum_{i=1}^Nx_{mi}, ..., x_R)`.
        The data type is the same with `tensors`.

    Raises:
        TypeError: If `axis` is not an int.
        ValueError: If `tensors` have different dimension of tensor.
        ValueError: If `axis` not in range :math:`[-R, R)`.
        ValueError: If tensor's shape in `tensors` except for `axis` are different.
        ValueError: If `tensors` is an empty tuple or list.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input_x1 = Tensor(np.array([[0, 1], [2, 1]]).astype(np.float32))
        >>> input_x2 = Tensor(np.array([[0, 1], [2, 1]]).astype(np.float32))
        >>> output = ops.cat((input_x1, input_x2))
        >>> print(output)
        [[0. 1.]
         [2. 1.]
         [0. 1.]
         [2. 1.]]
        >>> output = ops.cat((input_x1, input_x2), 1)
        >>> print(output)
        [[0. 1. 0. 1.]
         [2. 1. 2. 1.]]
    """
    return concat_impl(tensors, axis)


def conj(input):
    r"""
    Returns a tensor of complex numbers that are the complex conjugate of each element in input.
    The complex numbers in input must be of the form a + bj, where a is the real part and b is the imaginary part.

    The complex conjugate returned by this operation is of the form a - bj.

    If `input` is real, it is returned unchanged.

    Args:
        input (Tensor): The input tensor to compute to. Must have numeric type.

    Returns:
        Tensor, has the same dtype as the `input`.

    Raises:
        TypeError: If the dtype of `input` is not a numeric type.
        TypeError: If the `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.asarray(np.complex(1.3+0.4j)), mindspore.complex64)
        >>> output = ops.conj(x)
        >>> print(output)
        (1.3-0.4j)
    """
    return conj_op(input)


def contiguous(input):
    r"""
    Converts a Tensor into a continuous-memory Tensor that contains the same data as the original Tensor.

    Returns:
        A contiguous in memory tensor containing the same data as self tensor.

    Examples:
        >>> import mindspore as ms
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor([[1, 2, 3], [4, 5, 6]], dtype=ms.float32)
        >>> y = ops.transpose(x, (1, 0))
        >>> y.contiguous()
        >>> y[:, 1] = 1
        >>> print(x)
        [[1. 2. 3.]
         [4. 5. 6.]]
    """
    return contiguous_op(input)


def copy(input):
    r"""
    
    """
    return copy_op(input)


def correlate(a, v, mode='valid'):
    r"""
    Cross-correlation of two 1-dimensional sequences.

    This function computes the correlation as generally defined in signal processing texts:

    :math:`c_{av}[k] = \sum_{n}{a[n+k] * conj(v[n])}`

    with `a` and `v` sequences being zero-padded where necessary and conj being the conjugate.

    Note:
        - `correlate` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `correlate` is not supported on Windows platform yet.

    Args:
        a (Union[list, tuple, Tensor]): First input sequence.
        v (Union[list, tuple, Tensor]): Second input sequence.
        mode (str, optional): Specifies padding mode. The optional values are
            ``"same"`` , ``"valid"`` and ``"full"`` . Default: ``"valid"`` .

            - ``"same"``: it returns output of length :math:`max(M, N)`. Boundary
              effects are still visible.

            - ``"valid"``: it returns output of length :math:`max(M, N) - min(M, N) + 1`.
              The convolution product is only given for points where the signals overlap
              completely. Values outside the signal boundary have no effect.

            - ``"full"``: it returns the convolution at each point of overlap, with
              an output shape of :math:`(N + M - 1,)`.At the end-points of the convolution,
              the signals do not overlap completely, and boundary effects may be seen.

    Returns:
        Tensor, Discrete cross-correlation of `a` and `v`.

    Raises:
        TypeError: If `a` or `v` is not a tensor.
        TypeError: If `a` and `v` is of different dtype.
        ValueError: If `a` and `v` are empty or have wrong dimensions

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> from mindspore.ops.auto_generate import correlate
        >>> from mindspore import Tensor
        >>> output = correlate(Tensor([1., 2., 3.]), Tensor([0., 1., 0.5]))
        >>> print(output)
        [3.5]
        >>> output = correlate(Tensor([1., 2., 3.]), Tensor([0., 1., 0.5]), mode="same")
        >>> print(output)
        [2.  3.5 3. ]
        >>> output = correlate(Tensor([1., 2., 3., 4., 5.]), Tensor([1., 2.]), mode="full")
        >>> print(output)
        [ 2.  5.  8. 11. 14.  5.]
    """
    correlate_op = _get_cache_prim(Correlate)(mode)
    return correlate_op(a, v)


def cos(input):
    r"""
    Computes cosine of input element-wise.

    .. math::
        out_i = \cos(x_i)

    .. warning::
        Using float64 may cause a problem of missing precision.

    Args:
        input (Tensor): The shape of tensor is
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.

    Returns:
        Tensor, has the same shape as the `input`. 
        The dtype of output is float32 when dtype of `input` is in
        [bool, int8, uint8, int16, int32, int64]. Otherwise output has the same dtype as the `input`.

    :raise TypeError: If `input` is not a Tensor.
    :raise TypeError:
        * CPU/GPU: If dtype of `input` is not float16, float32 or float64, complex64, complex128.
        * Ascend: If dtype of `input` is not bool, int8, uint8, int16, int32, int64, float16, float32, float64, complex64, complex128.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.24, 0.83, 0.31, 0.09]), mindspore.float32)
        >>> output = ops.cos(input)
        >>> print(output)
        [0.971338 0.6748758 0.95233357 0.9959527]
    """
    return cos_op(input)


def cosh(input):
    r"""
    Computes hyperbolic cosine of input element-wise.

    .. math::

        out_i = \cosh(input_i)

    Args:
        input (Tensor): The input tensor of hyperbolic cosine function, its data type
            must be float16, float32, float64, complex64 or complex128.

    Returns:
        Tensor, has the same shape as `input`.

    Raises:
        TypeError: If the dtype of `input` is not one of the following types:
                       float16, float32, float64, complex64, complex128.
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([0.24, 0.83, 0.31, 0.09]), mindspore.float32)
        >>> output = ops.cosh(x)
        >>> print(output)
        [1.0289385 1.364684 1.048436 1.0040528]
        >>> x = Tensor(2.1, mindspore.float32)
        >>> output = ops.cosh(x)
        >>> print(output)
        4.144313
    """
    return cosh_op(input)


def cummax(input, axis):
    r"""
    Returns a tuple (values,indices) where 'values' is the cumulative maximum value of input Tensor `input`
    along the dimension `axis`, and `indices` is the index location of each maximum value.

    .. math::
        \begin{array}{ll} \\
            y_{i} = \max(x_{1}, x_{2}, ... , x_{i})
        \end{array}

    Args:
        input (Tensor): The input Tensor, rank of `input` > 0.
        axis (int): The dimension to do the operation over. The value of `axis` must be in the range
            `[-input.ndim, input.ndim - 1]`.

    Returns:
        tuple [Tensor], tuple of 2 Tensors, containing the cumulative maximum of elements and the index.
        The shape of each output tensor is the same as input `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If `axis` is not an int.
        ValueError: If `axis` is out the range of `[-input.ndim, input.ndim - 1]`.

    Supported Platforms:
        ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor
        >>> import mindspore.ops as ops
        >>> x = Tensor(np.array([[3, 4, 6, 10], [1, 6, 7, 9], [4, 3, 8, 7], [1, 3, 7, 9]]).astype(np.float32))
        >>> output = ops.cummax(x, axis=0)
        >>> print(output[0])
        [[ 3.  4.  6. 10.]
         [ 3.  6.  7. 10.]
         [ 4.  6.  8. 10.]
         [ 4.  6.  8. 10.]]
        >>> print(output[1])
        [[0 0 0 0]
         [0 1 1 0]
         [2 1 2 0]
         [2 1 2 0]]
    """
    return cummax_impl(input, axis)


def cumsum_ext(input, dim, dtype=None):
    r"""
    Computes the cumulative sum of input Tensor along `dim`.

    .. math::

        y_i = x_1 + x_2 + x_3 + ... + x_i

    Note:
        On Ascend, the dtype of `x` only support :int8, uint8, int32, float16 or float32 in case of static shape.
        For the case of dynamic shape, the dtype of `x` only support int32, float16 or float32.

    Args:
        input (Tensor): The input Tensor of shape :math:`(N, *)` where :math:`*` means, any number
            of additional dimensions.
        dim (int): Dim along which the cumulative sum is computed.
        dtype (:class:`mindspore.dtype`, optional): The desired dtype of returned Tensor. If specified,
            the input Tensor will be cast to `dtype` before the computation. This is useful for preventing overflows.
            If not specified, stay the same as original Tensor. Default: ``None`` .

    Returns:
        Tensor, the shape of the output Tensor is consistent with the input Tensor's.

    Raises:
        TypeError: If `input` is not a Tensor.
        ValueError: If the dim is out of range.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor
        >>> import mindspore.mint as mint
        >>> x = Tensor(np.array([[3, 4, 6, 10], [1, 6, 7, 9], [4, 3, 8, 7], [1, 3, 7, 9]]).astype(np.float32))
        >>> # case 1: along the dim 0
        >>> y = mint.cumsum(x, 0)
        >>> print(y)
        [[ 3.  4.  6. 10.]
        [ 4. 10. 13. 19.]
        [ 8. 13. 21. 26.]
        [ 9. 16. 28. 35.]]
        >>> # case 2: along the dim 1
        >>> y = mint.cumsum(x, 1)
        >>> print(y)
        [[ 3.  7. 13. 23.]
        [ 1.  7. 14. 23.]
        [ 4.  7. 15. 22.]
        [ 1.  4. 11. 20.]]
    """
    return cumsum_ext_op(input, dim, dtype)


def decoder_k_v_cache(cache, update, valid_seq_len, batch_index, seq_len_axis, new_max_seq_len, cur_max_seq_len):
    r"""
    The DecoderKVCache is used for decoding the KVCache of transformer network.

    Args:
        cache (Tensor): The cahe tensor with data type of int8, uint8, int16, uint16, float16, float32 and int32.
          When format is BHSD, cache tensor of shape
          :math:`(batch\_size, num\_head, max\_seq\_length, size\_pre\_head)`.
          When format is BSD, cache tensor of shape
          :math:`(batch\_size, max\_seq\_length, hidden\_size)`.
        update (Tensor]): The tensor which is used to update the cache tensor. Same data type as cache tensor.
          When format is BHSD, update tensor of shape
          :math:`(batch\_size, num\_head, update\_seq\_length, size\_pre\_head)`.
          When format is BSD, update tensor of shape
          :math:`(batch\_size, update\_seq\_length, hidden\_size)`.
        valid_seq_len (Tensor): The valid_seq_len tensor with data type of int64.
          Valid_seq_len tensor of shape :math:`(batch\_size)`.
        batch_index (Tensor): The batch_index tensor with data type of int64.
          Batch_index tensor of shape :math:`(batch\_size)`. Indicate that which batch of cache tensor is going to be update. Not abel for now.
        seq_len_axis (Tensor): The seq_len_axis indicate which axis is seq_eln, set to '1' or '2'. Not able for now.
        new_max_seq_len (Tensor): The new_max_seq_len tensor with data type of int64.
          New_max_seq_len tensor of shape :math:`(1)`.
          Indicate that user want to change the shape of cache tensor from
          :math:`(batch\_size, num_head, max\_seq\_length, hidden\_size)`. to
          :math:`(batch\_size * max\_seq\_length / new\_max\_seq\_length, num_head, new\_max\_seq\_length, hidden\_size)`.
          to update the cache tensor. This will not real change the shape of `cache` tensor.
        cur_max_seq_len (Tensor): The new_max_seq_len tensor with data type of int64.
          Cur_max_seq_len tensor of shape :math:`(1)`. Keep the current seq_len of cache tensor. Not abel for now.

    Outputs:
        With same data type and same shape as `cache` tensor.

    Supported Platforms:
        ``Ascend``

    Examples:
        >>> from mindspore.ops.operations import _inner_ops
        >>> b = 4
        >>> h = 40
        >>> max_s = 1024
        >>> s = 1
        >>> d = 128
        >>> cache = Tensor(np.random.randn(b, h, max_s, d).astype(np.float16))
        >>> update = Tensor(np.random.randn(b, h, s, d).astype(np.float16))
        >>> valid_seq_len = Tensor(np.random.randint(-1, s, size=b).astype(np.int64))
        >>> batch_index = Tensor(np.random.choice(np.arange(-1, b), size=b, replace=False).astype(np.int64))
        >>> new_max_seq_len = Tensor(np.random.randn(1).astype(np.int64))
        >>> cur_max_seq_len = Tensor(np.random.randn(1).astype(np.int64))
        >>> decoder_kv_cache = _inner_ops.DecoderKVCache()
        >>> output = decoder_kv_cache(cache, update, valid_seq_len, batch_index, Tensor(2), new_max_seq_len, cur_max_seq_len)
        >>> print(cache)
    """
    return decoder_k_v_cache_op(cache, update, valid_seq_len, batch_index, seq_len_axis, new_max_seq_len,
                                cur_max_seq_len)


def dense(input, weight, bias=None):
    r"""
    Applies the dense connected operation to the `input`. The dense function is defined as:

    .. math::
        output = input * weight^{T} + bias

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        input (Tensor): Input Tensor of shape :math:`(*, in\_channels)`,
            where :math:`*` means any number of additional dimensions.
        weight (Tensor): The weight applied to the input.
            The shape is :math:`(out\_channels, in\_channels)` or :math:`(in\_channels)`.
        bias (Tensor, optional): Additive biases to the output.
            The shape is :math:`(out\_channels)` or :math:`()`. Defaults: ``None``, the `bias` is 0.

    Returns:
        Output whose shape is determined by the shape of the input and the weight.

    Raises:
        TypeError: If `input` is not Tensor.
        TypeError: If `weight` is not Tensor.
        TypeError: If `bias` is not Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU``  ``CPU``

    Examples:
        >>> import numpy as np
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([[-1., 1., 2.], [-3., -3., 1.]], mindspore.float32)
        >>> weight = Tensor([[-2., -2., -2.], [0., -1., 0.]], mindspore.float32)
        >>> bias = Tensor([0., 1.], mindspore.float32)
        >>> output = ops.dense(input, weight, bias)
        >>> print(output)
        [[-4.  0.]
         [10.  4.]]
    """
    return dense_op(input, weight, bias)


def diag(input):
    r"""
    Constructs a diagonal tensor with a given diagonal values.

    Assume `input` has dimensions :math:`(D_1,... D_k)` , the output is a tensor of
    rank 2k with dimensions :math:`(D_1,..., D_k, D_1,..., D_k)` where:
    :math:`output[i_1,..., i_k, i_1,..., i_k] = input[i_1,..., i_k]` and 0 everywhere else.

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        input (Tensor): The input tensor.

    Returns:
        Tensor, has the same dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        ValueError: If rank of `input` less than 1.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([1, 2, 3, 4]).astype('int32')
        >>> output = ops.diag(input)
        >>> print(output)
        [[1 0 0 0]
         [0 2 0 0]
         [0 0 3 0]
         [0 0 0 4]]
    """
    return diag_op(input)


def diagonal(input, offset=0, dim1=0, dim2=1):
    r"""
    Returns specified diagonals of `input`.

    If `input` is 2-D, returns the diagonal of `input` with the given offset.
    If `input` has more than two
    dimensions, then the axes specified by `dim1` and `dim2` are used to determine
    the 2-D sub-array whose diagonal is returned. In this case, remove the `dim1` and `dim2` dimensions of `input`
    and insert the last dimension of `input` by the diagonal elements determined by `dim1` and `dim2`.

    Args:
        input (Tensor): Array from which the diagonals are taken.
        offset (int, optional): Offset of the diagonal from the main diagonal.
            Can be positive or negative. Default: ``0`` .
        dim1 (int, optional): Axis to be used as the first axis of the 2-D
            sub-arrays from which the diagonals should be taken. Defaults to
            first axis (0). Default: ``0`` .
        dim2 (int, optional): Axis to be used as the second axis of the 2-D
            sub-arrays from which the diagonals should be taken. Defaults to
            second axis (1). Default: ``1`` .

    Returns:
        Tensor, if `input` is 2-D, then `input` 1-D array containing the diagonal. If
        ``input.ndim > 2``, then the dimensions specified by `dim1` and `dim2` are removed,
        and a new axis inserted at the end corresponding to the diagonal.

    Raises:
        TypeError: if `dim1` or `dim2` are not an int.
        ValueError: if the input tensor has less than two dimensions.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> from mindspore import Tensor, ops
        >>> from mindspore import dtype as mstype
        >>> x = Tensor([[0, 1], [2, 3]], mstype.float32)
        >>> output = ops.diagonal(x)
        >>> print(output)
        [0 3]
    """
    diagonal_op = _get_cache_prim(Diagonal)(offset, dim1, dim2)
    return diagonal_op(input)


def dot(input, other):
    r"""
    
    """
    return dot_op(input, other)


def elu(input_x, alpha=1.0):
    r"""
    Exponential Linear Unit activation function.

    Applies the exponential linear unit function element-wise.
    The activation function is defined as:

    .. math::

        \text{ELU}(x)= \left\{
        \begin{array}{align}
            \alpha(e^{x}  - 1) & \text{if } x \le 0\\
            x & \text{if } x \gt 0\\
        \end{array}\right.

    Where :math:`x` is the element of input Tensor `input_x`, :math:`\alpha` is param `alpha`,
    it determines the smoothness of ELU.
    The picture about ELU looks like this `ELU <https://en.wikipedia.org/wiki/
    Activation_function#/media/File:Activation_elu.svg>`_ .

    ELU function graph:

    .. image:: ../images/ELU.png
        :align: center

    Args:
        input_x (Tensor): The input of ELU is a Tensor of any dimension with data type of float16 or float32.
        alpha (float, optional): The alpha value of ELU, the data type is float. Only support ``1.0`` currently.
            Default: ``1.0`` .

    Returns:
        Tensor, has the same shape and data type as `input_x`.

    Raises:
        TypeError: If `alpha` is not a float.
        TypeError: If dtype of `input_x` is neither float16 nor float32.
        ValueError: If `alpha` is not equal to 1.0.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[-1.0, 4.0, -8.0], [2.0, -5.0, 9.0]]), mindspore.float32)
        >>> output = ops.elu(x)
        >>> print(output)
        [[-0.63212055  4.         -0.99966455]
         [ 2.         -0.99326205  9.        ]]
    """
    elu_op = _get_cache_prim(Elu)(alpha)
    return elu_op(input_x)


def equal(input, other):
    r"""
    Computes the equivalence between two tensors element-wise.

    The second argument can be a number or a tensor whose shape is broadcastable with the first argument and vise versa.

    .. math::

        out_{i} =\begin{cases}
            & \text{True,    if } input_{i} = other_{i} \\
            & \text{False,   if } input_{i} \ne other_{i}
            \end{cases}

    Note:
        - `input` and `other` comply with the implicit type conversion rules to make the data types consistent.
        - The shapes of the inputs can be broadcasted to each other.

    Args:
        input (Union[Tensor, Number]): The first input is a number or
            a tensor whose data type is number.
        other (Union[Tensor, Number]): The second input is a number or
            a tensor whose data type is number.

    Returns:
        Tensor, the shape is the same as the one after broadcasting, and the data type is bool.

    Raises:
        TypeError: If neither `input` nor `other` is a Tensor or number.Number.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> # case 1: The shape of two inputs are different
        >>> input = Tensor([1, 2, 3], mindspore.float32)
        >>> output = ops.equal(input, 2.0)
        >>> print(output)
        [False True False]
        >>> # case 2: The shape of two inputs are the same
        >>> input = Tensor([1, 2, 3], mindspore.int32)
        >>> other = Tensor([1, 2, 4], mindspore.int32)
        >>> output = ops.equal(input, other)
        >>> print(output)
        [ True  True False]
    """
    return equal_op(input, other)


def erf(input):
    r"""
    Computes the Gauss error function of `input` element-wise.

    .. math::

        erf(x)=\frac{2} {\sqrt{\pi}} \int\limits_0^{x} e^{-t^{2}} dt

    Args:
        input (Tensor): The input tensor of Gaussian error function. :math:`x` in the following formula.
            Supported dtypes: 

            - Ascend: float16, float32, int64, bool.
            - GPU/CPU: float16, float32, float64.

    Returns:
        Tensor. If the input is int64 or bool, the return value type is float32. 
        Otherwise, the return value type is the same as the input type.


    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not as follows

            - Ascend: float16, float32, int64, bool.
            - GPU/CPU: float16, float32, float64.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([-1, 0, 1, 2, 3]), mindspore.float32)
        >>> output = ops.erf(input)
        >>> print(output)
        [-0.8427168   0.          0.8427168   0.99530876  0.99997765]
    """
    return erf_op(input)


def erfc(input):
    r"""
    Computes the complementary error function of `input` element-wise.

    .. math::

        erfc(x) = 1 - \frac{2} {\sqrt{\pi}} \int\limits_0^{x} e^{-t^{2}} dt

    Args:
        input (Tensor): The input tensor of the complementary error function, :math:`x` in the above formula. 
            Supported dtypes:

            - Ascend: float16, float32.
            - GPU/CPU: float16, float32, float64.

    Returns:
        Tensor, has the same shape and dtype as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not float16, float32 or float64.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([-1, 0, 1, 2, 3]), mindspore.float32)
        >>> output = ops.erfc(x)
        >>> print(output)
        [1.8427168e+00 1.0000000e+00 1.5728319e-01 4.6912432e-03 2.2351742e-05]
    """
    return erfc_op(input)


def erfinv(input):
    r"""
    Returns the result of the inverse error function with `input`, which is defined in the range `(-1, 1)` as:

    .. math::

        erfinv(erf(x)) = x

    where :math:`x` is the `input`.

    Args:
        input (Tensor): The input tensor to compute with.
            Supported dtypes:

            - Ascend: float16, float32, int8, int16, int32, int64, uint8, bool.
            - GPU/CPU: float16, float32 or float64.

    Returns:
        Tensor, has the same shape and dtype as `input`.

    :raise TypeError: If dtype of `input` is not as follows

        - Ascend: float16, float32, int8, int16, int32, int64, uint8, bool.
        - GPU/CPU: float16, float32 or float64.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0, 0.5, -0.9]), mindspore.float32)
        >>> output = ops.erfinv(input)
        >>> print(output)
        [ 0.          0.47695306 -1.1630805 ]
    """
    return erfinv_op(input)


def exp(input):
    r"""
    Returns exponential of a tensor element-wise.

    .. math::
        out_i = e^{x_i}

    Args:
        input (Tensor): The input tensor. :math:`x` in the following formula.

    Returns:
        Tensor, has the same shape as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.0, 1.0, 3.0]), mindspore.float32)
        >>> output = ops.exp(input)
        >>> print(output)
        [ 1.        2.718282 20.085537]
    """
    return exp_op(input)


def expand_dims(input_x, axis):
    r"""
    Adds an additional dimension to `input_x` at the given axis, the dimension
    of `input_x` should be greater than or equal to 1.

    Note:
        If the specified axis is a negative number, the index is counted
        backward from the end and starts at 1.

    Args:
        input_x (Tensor): The shape of tensor is :math:`(x_1, x_2, ..., x_R)`.
        axis (int): Specifies the dimension index at which to expand
            the shape of `input_x`. The value of axis must be in the range
            `[-input_x.ndim-1, input_x.ndim]`. Only constant value is allowed.

    Returns:
        Tensor, the shape of tensor is :math:`(1, x_1, x_2, ..., x_R)` if the
        value of `axis` is 0. It has the same data type as `input_x`.

    Raises:
        TypeError: If `axis` is not an int.
        ValueError: If `axis` is not in the valid range :math:`[-a.ndim-1, a.ndim]`.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input_tensor = Tensor(np.array([[2, 2], [2, 2]]), mindspore.float32)
        >>> output = ops.expand_dims(input_tensor, 0)
        >>> print(output)
        [[[2. 2.]
          [2. 2.]]]
    """
    return expand_dims_op(input_x, axis)


def expm1(input):
    r"""
    Returns exponential then minus 1 of a tensor element-wise.

    .. math::

      out_i = e^{x_i} - 1

    Args:
      input (Tensor): The input Tensor. :math:`x` in the above formula.

    Returns:
      Tensor, has the same shape as the `input`.

    Raises:
      TypeError: If `input` is not a Tensor.

    Supported Platforms:
      ``Ascend`` ``GPU`` ``CPU``

    Examples:
      >>> import mindspore
      >>> import numpy as np
      >>> from mindspore import Tensor, ops
      >>> x = Tensor(np.array([0.0, 1.0, 2.0, 4.0]), mindspore.float32)
      >>> output = ops.expm1(x)
      >>> print(output)
      [ 0.        1.718282  6.389056 53.598152]
    """
    return expm1_op(input)


def extract_image_patches(input_x, ksizes, strides, rates, padding='VALID'):
    r"""
    Extracts patches from images.
    The input tensor must be a 4-D tensor and the data format is NCHW.

    Args:
        input_x (Tensor): A 4-D tensor whose shape is :math:`(in\_batch, in\_depth, in\_row, in\_col)`.
        ksizes (Union[tuple[int], list[int]]): The size of sliding window, must be a tuple or a list of integers,
            the size must be 4, and the format is [1, 1, ksize_row, ksize_col].
        strides (Union[tuple[int], list[int]]): Distance between the centers of the two consecutive patches,
            must be a tuple or list of int, the size must be 4, and the format is [1, 1, stride_row, stride_col].
        rates (Union[tuple[int], list[int]]): In each extracted patch, the gap between the corresponding dimension
            pixel positions, must be a tuple or a list of integers, the size must be 4, and the format is [1, 1, rate_row, rate_col].
        padding (str): The type of padding algorithm, is a string whose value is "same" or "valid",
            not case sensitive. Default: "valid".

            - same: Means that the patch can take the part beyond the original image, and this part is filled with 0.

            - valid: Means that the taken patch area must be completely covered in the original image.

    Outputs:
        Tensor, a 4-D tensor whose data type is same as 'input_x', and the shape
        is :math:`(out\_batch, out\_depth, out\_row, out\_col)`,where the out_batch is the same as the in_batch
        and

        .. math::
            out_depth=ksize\_row * ksize\_col * in\_depth

        and
        if 'padding' is "valid":

        .. math::
            out\_row=floor((in\_row - (ksize\_row + (ksize\_row - 1) * (rate\_row - 1))) / stride\_row) + 1
            out\_col=floor((in\_col - (ksize\_col + (ksize\_col - 1) * (rate\_col - 1))) / stride\_col) + 1

        if 'padding' is "same":

        .. math::
            out\_row=floor((in\_row - 1) / stride\_row) + 1
            out\_col=floor((in\_col - 1) / stride\_col) + 1

    Supported Platforms:
        ``Ascend`` ``GPU``
    """
    extract_image_patches_op = _get_cache_prim(ExtractImagePatches)(ksizes, strides, rates, padding)
    return extract_image_patches_op(input_x)


def fast_gelu(x):
    r"""
    Fast Gaussian Error Linear Units activation function.

    FastGeLU is defined as follows:

    .. math::
        \text{output} = \frac {x} {1 + \exp(-1.702 * \left| x \right|)} * \exp(0.851 * (x - \left| x \right|)),

    where :math:`x` is the element of the input.

    FastGelu function graph:

    .. image:: ../images/FastGelu.png
        :align: center

    Args:
        x (Tensor): Input to compute the FastGeLU with data type of float16 or float32.

    Returns:
        Tensor, with the same type and shape as `x`.

    Raises:
        TypeError: If dtype of `x` is neither float16 nor float32.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[-1.0, 4.0, -8.0], [2.0, -5.0, 9.0]]), mindspore.float32)
        >>> output = ops.fast_gelu(x)
        >>> print(output)
        [[-1.5418735e-01  3.9921875e+00 -9.7473649e-06]
        [ 1.9375000e+00 -1.0052517e-03  8.9824219e+00]]
    """
    return fast_gelu_op(x)


def ffn_ext(x, weight1, weight2, expertTokens=None, bias1=None, bias2=None, scale=None, offset=None, deqScale1=None,
            deqScale2=None, antiquant_scale1=None, antiquant_scale2=None, antiquant_offset1=None,
            antiquant_offset2=None, activation='fastgelu', inner_precise=0):
    r"""
    
    """
    return ffn_ext_impl(x, weight1, weight2, expertTokens, bias1, bias2, scale, offset, deqScale1, deqScale2,
                        antiquant_scale1, antiquant_scale2, antiquant_offset1, antiquant_offset2, activation,
                        inner_precise)


def fft2(input, s=None, dim=(-2, -1), norm=None):
    r"""
    Calculates the two dimensional discrete Fourier transform of `input`.

    Note:
        - `fft2` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `fft2` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `fft2`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `fft2`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as, where :math:`n = prod(s)`

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `fft2()` function. The default is the same shape as `input`.
        If `s` is given, the size of the `dim[i]` axis is changed to `s[i]`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((4, 4))
        >>> out = ops.fft2(input, s=(4, 4), dim=(0, 1), norm="backward")
        >>> print(out)
        [[16.+0.j  0.+0.j  0.+0.j  0.+0.j]
         [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j]
         [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j]
         [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j]]
    """
    return fft2_op(input, s, dim, norm)


def fft(input, n=None, dim=-1, norm=None):
    r"""
    Calculates the one dimensional discrete Fourier transform of `input`.

    Note:
        - `fft` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `fft` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        n (int, optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim` axis will be zero-padded or truncated to `n` before calculating `fft`.
            Default: ``None`` , which does not need to process `input`.
        dim (int, optional): The dimension along which to take the one dimensional `fft`.
            Default: ``-1`` , which means transform the last dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `fft()` function. The default is the same shape as `input`.
        If `n` is given, result.shape[dim] is `n`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If `n` or `dim` type is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `n` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([ 1.6243454, -0.6117564, -0.5281718, -1.0729686])
        >>> ops.fft(input)
        [-0.5885514+0.j          2.1525173-0.46121222j  2.7808986+0.j
          2.1525173+0.46121222j]
    """
    return fft_op(input, n, dim, norm)


def fftn(input, s=None, dim=None, norm=None):
    r"""
    Computes the N dimensional discrete Fourier transform of `input`.

    Note:
        - `fftn` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `fftn` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `fftn`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `fftn`.
            Default: ``None`` , which means transform the all dimension of `input`, or the last `len(s)` dimensions if s is given.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `fftn()` function. The default is the same shape as `input`.
        If `s` is given, the size of the `dim[i]` axis is changed to `s[i]`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((2, 2, 2))
        >>> out = ops.fftn(input, s=(2, 2, 2), dim=(0, 1, 2), norm="backward")
        >>> print(out)
        [[[8.+0.j 0.+0.j]
          [0.+0.j 0.+0.j]]
          [[0.+0.j 0.+0.j]
          [0.+0.j 0.+0.j]]]
    """
    return fftn_op(input, s, dim, norm)


def fftshift(input, dim=None):
    r"""
    Shift the zero-frequency component to the center of the spectrum.

    Note:
        - `fftshift` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `fftshift` is not supported on Windows platform yet.

    Args:
        input (Tensor): Input tensor.
        dim (Union[int, list(int), tuple(int)], optional): The dimensions which to shift.
            Default is ``None``, which shifts all dimensions.

    Returns:
        output (Tensor), the shifted tensor with the same shape and dtype as `input`.

    Raises:
        TypeError: If `input` is not a tensor.
        TypeError: If the type/dtype of `dim` is not int.
        ValueError: If `dim` is out of the range of :math:`[-input.ndim, input.ndim)`.

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> from mindspore.ops import fftshift
        >>> from mindspore import Tensor
        >>> from mindspore import dtype as mstype
        >>> input = Tensor([0, 1, 2, 3, 4, -5, -4, -3, -2, -1], dtype=mstype.int32)
        >>> fftshift(input)
        Tensor(shape=[10], dtype=Int32, value= [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4])
    """
    return fftshift_op(input, dim)


def floor_divide(input, other):
    r"""
    Divides the first input tensor by the second input tensor element-wise and round down to the closest integer.

    Inputs of `input` and `other` comply with the implicit type conversion rules to make the data types consistent.
    When the inputs are two tensors,
    dtypes of them cannot be bool at the same time, and the shapes of them could be broadcast.
    When the inputs are one tensor and one scalar,
    the scalar could only be a constant.

    .. math::
        out_{i} = \text{floor}( \frac{input_i}{other_i})

    where the :math:`floor` indicates the Floor operator, for more details,
    please refer to the :class:`mindspore.ops.Floor` operator.

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        input (Union[Tensor, Number, bool]): The first input is a number or
            a bool or a tensor whose data type is number or bool.
        other (Union[Tensor, Number, bool]): The second input is a number or
            a bool or a tensor whose data type is number or bool.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs.

    Raises:
        TypeError: If `input` and `other` are not the following: Tensor, number.Number or bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> import numpy as np
        >>> input = Tensor(np.array([2, 4, -1]), mindspore.int32)
        >>> other = Tensor(np.array([3, 3, 3]), mindspore.int32)
        >>> output = ops.floor_divide(input, other)
        >>> print(output)
        [ 0  1 -1]
        >>> input = Tensor(2.0, mindspore.float32)
        >>> other = Tensor(2.0, mindspore.float32)
        >>> output = ops.floor_divide(input, other)
        >>> print(output)
        1.0
    """
    return floor_div_op(input, other)


def floor_mod(x, y):
    r"""
    Computes the remainder of division element-wise. It's a flooring divide.
    E.g. :math:`floor(x / y) * y + mod(x, y) = x`.

    Inputs of `x` and `y` comply with the implicit type conversion rules to make the data types consistent.
    When the inputs are two tensors,
    dtypes of them cannot be both bool, and the shapes of them could be broadcast.
    When the inputs are one tensor and one scalar,
    the scalar could only be a constant.

    .. math::

        out_{i} =\text{floor}(x_{i} // y_{i})

    where the :math:`floor` indicates the Floor operator, for more details,
    please refer to the :class:`mindspore.ops.Floor` operator.

    .. warning::
        - Data of input `y` should not be 0, or the maximum value of its dtype will be returned.
        - When the elements of input exceeds 2048 , the accuracy of operator cannot guarantee the requirement of
          double thousandths in the mini form.
        - Due to different architectures, the calculation results of this operator on NPU and CPU may be inconsistent.
        - If shape is expressed as :math:`(D1, D2 ..., Dn)`, then D1\*D2... \*DN<=1000000,n<=8.

    Args:
        x (Union[Tensor, Number, bool]): The first input is a number or
            a bool or a tensor whose data type is number or bool.
        y (Union[Tensor, Number, bool]): The second input is a number or
            a bool or a tensor whose data type is number or bool.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,
        and the data type is the one with higher precision of the two inputs.

    Raises:
        TypeError: If neither `x` nor `y` is a Tensor, number.Number, or bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([2, 4, -1]), mindspore.int32)
        >>> y = Tensor(np.array([3, 3, 3]), mindspore.int32)
        >>> output = ops.floor_mod(x, y)
        >>> print(output)
        [2 1 2]
    """
    return floor_mod_op(x, y)


def floor(input):
    r"""
    Rounds a tensor down to the closest integer element-wise.

    .. math::

        out_i = \lfloor x_i \rfloor

    Args:
        input (Tensor): The input tensor, :math:`x` in the above formula. Its data type must be float16,
            float32 or float64.

    Returns:
        Tensor, has the same shape as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If dtype of `input` is not in [float16, float32, float64].

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1.1, 2.5, -1.5]), mindspore.float32)
        >>> output = ops.floor(input)
        >>> print(output)
        [ 1.  2. -2.]
    """
    return floor_op(input)


def gather_d(x, dim, index):
    r"""
    Gathers elements along an axis specified by dim.

    Refer to :func:`mindspore.ops.gather_elements` for more detail.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[1, 2], [3, 4]]), mindspore.int32)
        >>> index = Tensor(np.array([[0, 0], [1, 0]]), mindspore.int32)
        >>> dim = 1
        >>> output = ops.gather_d(x, dim, index)
        >>> print(output)
        [[1 1]
         [4 3]]
    """
    return gather_d_op(x, dim, index)


def gather_nd(input_x, indices):
    r"""
    Gathers slices from a tensor by indices.

    Using given indices to gather slices from a tensor with a specified shape.

    `indices` is an K-dimensional integer tensor.
    Supposes it as a (K-1)-dimensional tensor and each element of it defines a slice of `input_x`:

    .. math::

        output[(i_0, ..., i_{K-2})] = input\_x[indices[(i_0, ..., i_{K-2})]]

    The last dimension of `indices` can not more than the rank of `input_x`:

    :math:`indices.shape[-1] <= input\_x.rank`.

    Args:
        input_x (Tensor): The target tensor to gather values.
        indices (Tensor): The index tensor, with int32 or int64 data type.

    Returns:
        Tensor, has the same type as `input_x` and the shape is
        :math:`indices\_shape[:-1] + input\_x\_shape[indices\_shape[-1]:]`.

    Raises:
        ValueError: If length of shape of `input_x` is less than the last dimension of `indices`.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input_x = Tensor(np.array([[-0.1, 0.3, 3.6], [0.4, 0.5, -3.2]]), mindspore.float32)
        >>> indices = Tensor(np.array([[0, 0], [1, 1]]), mindspore.int32)
        >>> output = ops.gather_nd(input_x, indices)
        >>> print(output)
        [-0.1  0.5]
    """
    return gather_nd_op(input_x, indices)


def gather(input_params, input_indices, axis, batch_dims=0):
    r"""
    Returns the slice of the input tensor corresponding to the elements of `input_indices` on the specified `axis`.

    The following figure shows the calculation process of Gather commonly:

    .. image:: Gather.png

    where params represents the input `input_params`, and indices represents the index to be sliced `input_indices`.

    .. note::
        1. The value of input_indices must be in the range of `[0, input_param.shape[axis])`.
           On CPU and GPU, an error is raised if an out of bound indice is found. On Ascend, the results may be
           undefined.
        2. The data type of input_params cannot be
           `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ on Ascend
           platform currently.

    Args:
        input_params (Tensor): The original Tensor. The shape of tensor is :math:`(x_1, x_2, ..., x_R)`.
        input_indices (Tensor): Index tensor to be sliced, the shape of tensor is :math:`(y_1, y_2, ..., y_S)`.
            Specifies the indices of elements of the original Tensor. The data type can be int32 or int64.
        axis (Union(int, Tensor[int])): Specifies the dimension index to gather indices.
            It must be greater than or equal to `batch_dims`.
            When `axis` is a Tensor, the size must be 1.
        batch_dims (int): Specifies the number of batch dimensions. It must be less than or euqal to the rank
            of `input_indices`. Default: ``0`` .

    Returns:
        Tensor, the shape of tensor is
        :math:`input\_params.shape[:axis] + input\_indices.shape[batch\_dims:] + input\_params.shape[axis + 1:]`.

    Raises:
        TypeError:  If `axis` is not an int or Tensor.
        ValueError: If `axis` is a Tensor and its size is not 1.
        TypeError:  If `input_params` is not a tensor.
        TypeError:  If `input_indices` is not a tensor of type int.
        RuntimeError: If `input_indices` is out of range `[0, input_param.shape[axis])` on CPU or GPU.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> # case1: input_indices is a Tensor with shape (5, ).
        >>> input_params = Tensor(np.array([1, 2, 3, 4, 5, 6, 7]), mindspore.float32)
        >>> input_indices = Tensor(np.array([0, 2, 4, 2, 6]), mindspore.int32)
        >>> axis = 0
        >>> output = ops.gather(input_params, input_indices, axis)
        >>> print(output)
        [1. 3. 5. 3. 7.]
        >>> # case2: input_indices is a Tensor with shape (2, 2). When the input_params has one dimension,
        >>> # the output shape is equal to the input_indices shape.
        >>> input_indices = Tensor(np.array([[0, 2], [2, 6]]), mindspore.int32)
        >>> axis = 0
        >>> output = ops.gather(input_params, input_indices, axis)
        >>> print(output)
        [[1. 3.]
         [3. 7.]]
        >>> # case3: input_indices is a Tensor with shape (2, ) and
        >>> # input_params is a Tensor with shape (3, 4) and axis is 0.
        >>> input_params = Tensor(np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]), mindspore.float32)
        >>> input_indices = Tensor(np.array([0, 2]), mindspore.int32)
        >>> axis = 0
        >>> output = ops.gather(input_params, input_indices, axis)
        >>> print(output)
        [[ 1.  2.  3.  4.]
         [ 9. 10. 11. 12.]]
        >>> # case4: input_indices is a Tensor with shape (2, ) and
        >>> # input_params is a Tensor with shape (3, 4) and axis is 1, batch_dims is 1.
        >>> input_params = Tensor(np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]), mindspore.float32)
        >>> input_indices = Tensor(np.array([0, 2, 1]), mindspore.int32)
        >>> axis = 1
        >>> batch_dims = 1
        >>> output = ops.gather(input_params, input_indices, axis, batch_dims)
        >>> print(output)
        [ 1.  7. 10.]
    """
    gather_op = _get_cache_prim(Gather)(batch_dims)
    return gather_op(input_params, input_indices, axis)


def gcd(input, other):
    r"""
    Computes greatest common divisor of input tensors element-wise.
    The shape of two inputs should be broadcastable, and data type of them should be
    one of: int32, int64.

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        input (Tensor): The first input tensor.
        other (Tensor): The second input tensor.

    Returns:
        Tensor, the shape is the same as the one after broadcasting, and the data type is one
        with higher precision in the two inputs.

    Raises:
        TypeError: If data type `input` or `other` is not int32 or int64.
        ValueError: If shapes of two inputs are not broadcastable.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([7, 8, 9]))
        >>> other = Tensor(np.array([14, 6, 12]))
        >>> y = ops.gcd(input, other)
        >>> print(y)
        [7 2 3]
    """
    return gcd_op(input, other)


def geqrf(input):
    r"""
    Decomposes a matrix into the product of an orthogonal matrix `Q` and an upper triangular matrix `R`.
    The process is called QR decomposition: :math:`A = QR`.

    Both `Q` and `R` matrices are stored in the same output tensor `y`.
    The elements of `R` are stored on and above the diagonal, whereas elementary reflectors
    (or Householder vectors) implicitly defining matrix `Q` are stored below the diagonal.

    This function returns two tensors (`y`, `tau`).

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        input (Tensor): Tensor of shape :math:`(*, m, n)`, input must be a matrix greater than or equal to 2D,
            with dtype of float32, float64, complex64, complex128.

    Returns:
        - **y** (Tensor) - Tensor of shape :math:`(*, m, n)`, has the same dtype as the `input`.
        - **tau** (Tensor) - Tensor of shape :math:`(*, p)` and :math:`p = min(m, n)`, has the same dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If the dtype of `input` is not float32, float64, complex64 or complex128.
        ValueError: If dimension of `input` is less than 2.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([[-2.0, -1.0], [1.0, 2.0]]).astype(np.float32))
        >>> y, tau = ops.geqrf(input)
        >>> print(y)
        [[ 2.236068   1.7888544]
        [-0.236068   1.3416407]]
        >>> print(tau)
        [1.8944271 0.       ]
    """
    return geqrf_op(input)


def greater_equal(input, other):
    r"""
    Given two Tensors, compares them element-wise to check if each element in the first
    Tensor is greater than or equal to the corresponding element in the second Tensor.

    Refer to :func:`mindspore.ops.ge` for more details.

    Args:
        input (Union[Tensor, Number]): The first input is a number or
            a bool or a tensor whose data type is number or bool.
        other (Union[Tensor, Number]): The second input is a number
            or a tensor whose data type is number or bool.

    Returns:
        Tensor, the shape is the same as the one after broadcasting, and the data type is bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1, 2, 3]), mindspore.int32)
        >>> other = Tensor(np.array([1, 1, 4]), mindspore.int32)
        >>> output = ops.greater_equal(input, other)
        >>> print(output)
        [True True False]
    """
    return greater_equal_op(input, other)


def greater(input, other):
    r"""
    Compare the value of the input parameters :math:`input > other` element-wise, and the output result is a bool value.

    Refer to :func:`mindspore.ops.gt` for more details.

    Args:
        input (Union[Tensor, Number]): The first input is a Number or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ .
        other (Union[Tensor, Number]): The second input, which is a Number or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.

    Returns:
        Tensor, the shape is the same as the one after broadcasting, and the data type is bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1, 2, 3]), mindspore.int32)
        >>> other = Tensor(np.array([1, 1, 4]), mindspore.int32)
        >>> output = ops.greater(input, other)
        >>> print(output)
        [False True False]
    """
    return greater_op(input, other)


def hfft2(input, s=None, dim=(-2, -1), norm=None):
    r"""
    Calculates the two dimensional discrete Fourier transform of of a Hermitian symmetric `input`.

    Note:
        - `hfft2` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `hfft2` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `hfft2`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `hfft2`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `hfft2()` function.
        If `s` is given, result.shape[dim[i]] is s[i], and for the last transformed dim, 
        result.shape[dim[-1]] is :math:`(s[-1] - 1) * 2`, otherwise :math:`(input.shape[dim[-1]] - 1) * 2`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((4, 4))
        >>> out = ops.hfft2(input, s=(4, 4), dim=(0, 1), norm="backward")
        >>> print(out)
        [[16.  0.  0.  0.]
         [ 0.  0.  0.  0.]
         [ 0.  0.  0.  0.]
         [ 0.  0.  0.  0.]]
    """
    return hfft2_op(input, s, dim, norm)


def hfft(input, n=None, dim=-1, norm=None):
    r"""
    Calculates the one dimensional discrete Fourier transform of of a Hermitian symmetric `input` signal.

    Note:
        - `hfft` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `hfft` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        n (int, optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim` axis will be zero-padded or truncated to `n` before calculating `hfft`.
            Default: ``None`` , which does not need to process `input`.
        dim (int, optional): The dimension along which to take the one dimensional `hfft`.
            Default: ``-1`` , which means transform the last dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `hfft()` function.
        If `n` is given, result.shape[dim] is :math:`(n - 1) * 2`, otherwise :math:`(input.shape[dim] - 1) * 2`.
        When the `input` is int16, int32, int64, float16, float32, complex64, the return value type is float32.
        When the `input` is float64 or complex128, the return value type is float64.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If `n` or `dim` type is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `n` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([ 1.6243454, -0.6117564, -0.5281718, -1.0729686])
        >>> out = ops.hfft(input, n=4, dim=-1, norm="backward")
        >>> print(out)
        [-0.12733912  2.1525173   2.3196864   2.1525173 ]
    """
    return hfft_op(input, n, dim, norm)


def hfftn(input, s=None, dim=None, norm=None):
    r"""
    Calculates the N dimensional discrete Fourier transform of of a Hermitian symmetric `input`.

    Note:
        - `hfftn` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `hfftn` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `hfftn`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `hfftn`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `hfftn()` function.
        If `s` is given, result.shape[dim[i]] is s[i], and for the last transformed dim, 
        result.shape[dim[-1]] is :math:`(s[-1] - 1) * 2`, otherwise :math:`(input.shape[dim[-1]] - 1) * 2`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((4, 4))
        >>> out = ops.hfftn(input, s=(4, 4), dim=(0, 1), norm="backward")
        >>> print(out)
        [[16.  0.  0.  0.]
         [ 0.  0.  0.  0.]
         [ 0.  0.  0.  0.]
         [ 0.  0.  0.  0.]]
    """
    return hfftn_op(input, s, dim, norm)


def deepcopy(input_x):
    r"""
    Returns a deepcopy of input tensor.

    Args:
        input_x (Tensor): The shape of tensor is :math:`(x_1, x_2, ..., x_R)`.

    Returns:
        Tensor, a deepcopy of `input_x`.

    Raises:
        TypeError: If `input_x` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([[0, 1], [2, 1]], dtype=mindspore.int32)
        >>> output = ops.deepcopy(input)
        >>> print(output)
        [[0 1]
        [2 1]]
    """
    return identity_op(input_x)


def ifft2(input, s=None, dim=(-2, -1), norm=None):
    r"""
    Computes the two dimensional inverse discrete Fourier transform of `input`.

    Note:
        - `ifft2` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `ifft2` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `ifft2`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `ifft2`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as, where :math:`n = prod(s)`

            - ``"backward"`` (normalize by :math:`1/n`).
            - ``"forward"`` (no normalization).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `ifft2()` function. The default is the same shape as `input`.
        If `s` is given, the size of the `dim[i]` axis is changed to `s[i]`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((4, 4))
        >>> out = ops.ifft2(input, s=(4, 4), dim=(0, 1), norm="backward")
        >>>print(out)
        [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]
         [0.+0.j 0.+0.j 0.+0.j 0.+0.j]
         [0.+0.j 0.+0.j 0.+0.j 0.+0.j]
         [0.+0.j 0.+0.j 0.+0.j 0.+0.j]]
    """
    return ifft2_op(input, s, dim, norm)


def ifft(input, n=None, dim=-1, norm=None):
    r"""
    Calculates the inverse of `fft()`.

    Note:
        - `ifft` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `ifft` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        n (int, optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim` axis will be zero-padded or truncated to `n` before calculating `ifft`.
            Default: ``None`` , which does not need to process `input`.
        dim (int, optional): The dimension along which to take the one dimensional `ifft`.
            Default: ``-1`` , which means transform the last dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (normalize by :math:`1/n`).
            - ``"forward"`` (no normalization).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `ifft()` function. The default is the same shape as `input`.
        If `n` is given, result.shape[dim] is `n`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If `n` or `dim` type is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `n` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([ 1.6243454, -0.6117564, -0.5281718, -1.0729686])
        >>> out = ops.ifft(input, n=4, dim=-1, norm="backward")
        >>> print(out)
        [-0.14713785+0.j          0.5381293 +0.11530305j  0.69522464+0.j
          0.5381293 -0.11530305j]
    """
    return ifft_op(input, n, dim, norm)


def ifftn(input, s=None, dim=None, norm=None):
    r"""
    Computes the N dimensional inverse discrete Fourier transform of `input`.

    Note:
        - `ifftn` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `ifftn` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `ifftn`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `ifftn`.
            Default: ``None`` , which means transform the all dimension of `input`, or the last `len(s)` dimensions if s is given.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (normalize by :math:`1*n`).
            - ``"forward"`` (no normalization).
            - ``"ortho"`` (normalize by :math:`1*\sqrt{n}`).

    Returns:
        Tensor, The result of `ifftn()` function. The default is the same shape as `input`.
        If `s` is given, the size of the `dim[i]` axis is changed to `s[i]`.
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is complex64.
        When the input is float64 or complex128, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((2, 2, 2))
        >>> out = ops.ifftn(input, s=(2, 2, 2), dim=(0, 1, 2), norm="backward")
        >>> print(out)
        [[[1.+0.j 0.+0.j]
          [0.+0.j 0.+0.j]]
          [[0.+0.j 0.+0.j]
          [0.+0.j 0.+0.j]]]
    """
    return ifftn_op(input, s, dim, norm)


def ifftshift(input, dim=None):
    r"""
    The inverse of :func:`mindspore.ops.fftshift` .

    Note:
        - `ifftshift` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `ifftshift` is not supported on Windows platform yet.

    Args:
        input (Tensor): Input tensor.
        dim (Union[int, list(int), tuple(int)], optional): The dimensions which to shift.
            Default is ``None``, which shifts all dimensions.

    Returns:
        output (Tensor), the shifted tensor with the same shape and dtype as `input`.

    Raises:
        TypeError: If `input` is not a tensor.
        TypeError: If the type/dtype of `dim` is not int.
        ValueError: If `dim` is out of the range of :math:`[-input.ndim, input.ndim)`.

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> from mindspore.ops import fftshift, ifftshift
        >>> from mindspore import Tensor
        >>> from mindspore import dtype as mstype
        >>> input = Tensor([0, 1, 2, 3, 4, -5, -4, -3, -2, -1], dtype=mstype.int32)
        >>> ifftshift(fftshift(input))
        Tensor(shape=[10], dtype=Int32, value= [ 0, 1, 2, 3, 4, -5, -4, -3, -2, -1])
    """
    return ifftshift_op(input, dim)


def ihfft2(input, s=None, dim=(-2, -1), norm=None):
    r"""
    Computes the two dimensional inverse discrete Fourier transform of real `input`.

    Note:
        - `ihfft2` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `ihfft2` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `ihfft2`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `ihfft2`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1*n`).
            - ``"ortho"`` (normalize by :math:`1*\sqrt{n}`).

    Returns:
        Tensor, The result of `ihfft2()` function.
        If `s` is given, result.shape[dim[i]] is s[i], and for the last transformed dim, 
        result.shape[dim[-1]] is :math:`s[-1] // 2 + 1`, otherwise :math:`input.shape[dim[-1]] // 2 + 1`.
        When the input is int16, int32, int64, float16, float32, the return value type is complex64.
        When the input is float64, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((4, 4))
        >>> out = ops.ihfft2(input, s=(4, 4), dim=(0, 1), norm="backward")
        >>> print(out)
        [[1.-0.j 0.-0.j 0.-0.j]
         [0.-0.j 0.-0.j 0.-0.j]
         [0.-0.j 0.-0.j 0.-0.j]
         [0.-0.j 0.-0.j 0.-0.j]]
    """
    return ihfft2_op(input, s, dim, norm)


def ihfft(input, n=None, dim=-1, norm=None):
    r"""
    Calculates the inverse of `hfft()`.

    Note:
        - `ihfft` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `ihfft` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64.

        n (int, optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim` axis will be zero-padded or truncated to `n` before calculating `ihfft`.
            Default: ``None`` , which does not need to process `input`.
        dim (int, optional): The dimension along which to take the one dimensional `ihfft`.
            Default: ``-1`` , which means transform the last dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1*n`).
            - ``"ortho"`` (normalize by :math:`1*\sqrt{n}`).

    Returns:
        Tensor, The result of `ihfft()` function.
        If `n` is given, result.shape[dim] is :math:`n // 2 + 1`, otherwise :math:`input.shape[dim] // 2 + 1`.
        When the input is int16, int32, int64, float16, float32, the return value type is complex64.
        When the input is float64, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64.
        TypeError: If `n` or `dim` type is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `n` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([ 1.6243454, -0.6117564, -0.5281718, -1.0729686])
        >>> out = ops.ihfft(input, n=4, dim=-1, norm="backward")
        >>> print(out)
        [-0.14713785-0.j          0.5381293 +0.11530305j  0.69522464-0.j        ]
    """
    return ihfft_op(input, n, dim, norm)


def ihfftn(input, s=None, dim=None, norm=None):
    r"""
    Computes the N dimensional inverse discrete Fourier transform of real `input`.

    Note:
        - `ihfftn` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `ihfftn` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `ihfftn`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `ihfftn`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1*n`).
            - ``"ortho"`` (normalize by :math:`1*\sqrt{n}`).

    Returns:
        Tensor, The result of `ihfftn()` function.
        If `s` is given, result.shape[dim[i]] is s[i], and for the last transformed dim, 
        result.shape[dim[-1]] is :math:`s[-1] // 2 + 1`, otherwise :math:`input.shape[dim[-1]] // 2 + 1`.
        When the input is int16, int32, int64, float16, float32, the return value type is complex64.
        When the input is float64, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((4, 4))
        >>> out = ops.ihfftn(input, s=(4, 4), dim=(0, 1), norm="backward")
        >>> print(out)
        [[16.  0.  0.  0.]
         [ 0.  0.  0.  0.]
         [ 0.  0.  0.  0.]
         [ 0.  0.  0.  0.]]
    """
    return ihfftn_op(input, s, dim, norm)


def index_select(input, axis, index):
    r"""
    
    """
    return index_select_op(input, axis, index)


def irfft2(input, s=None, dim=(-2, -1), norm=None):
    r"""
    Calculates the inverse of `rfft2()`.

    Note:
        - `irfft2` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `irfft2` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `irfft2`.
            Default: ``None`` , the dim[-1] of the `input` will be zero-padded to :math:`2*(input.shape[dim[-1]]-1)`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `irfft2`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `irfft2()` function, result.shape[dim[i]] is s[i].
        When the input is int16, int32, int64, float16, float32, complex64, the return value type is float32.
        When the input is float64 or complex128, the return value type is float64.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((4, 4))
        >>> ops.irfft2(input, s=(4, 4), dim=(0, 1), norm="backward")
        Tensor(shape=[4, 4], dtype=Float32, value=
        [[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
         [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
         [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
         [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00]])
    """
    return irfft2_op(input, s, dim, norm)


def irfft(input, n=None, dim=-1, norm=None):
    r"""
    Calculates the inverse of `rfft()`.

    Note:
        - `irfft` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `irfft` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
        n (int, optional): Length of the transformed `dim` of the result.
            If given, the input will either be zero-padded or trimmed to this length before computing `irfft`.
            If n is not given, it is taken to be :math:`2*(input.shape[dim]-1)`.
            Default: ``None``.
        dim (int, optional): The dimension along which to take the one dimensional `irfft`.
            Default: ``-1``, which means transform the last dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"``.
            Three modes are defined as,

            - ``"backward"`` (normalize by :math:`1/n`).
            - ``"forward"`` (no normalization).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, the result of `irfft()` function, dtype of the result is float32/64, result.shape[dim] is :math:`n`.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int16, int32, int64, float32, float64, complex64, complex128.
        TypeError: If `n` or `dim` type is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `n` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"``.

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([1, 2, 3, 4])
        >>> y = ops.irfft(input, n=6, dim=-1, norm='backward')
        >>> print(y)
        [ 2.5        -0.6666667   0.         -0.16666667  0.         -0.6666667 ]
    """
    return irfft_op(input, n, dim, norm)


def irfftn(input, s=None, dim=None, norm=None):
    r"""
    Calculates the inverse of `rfftn()`.

    Note:
        - `irfftn` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `irfftn` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64, complex64, complex128.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `irfftn`.
            Default: ``None`` , the dim[-1] of the `input` will be zero-padded to :math:`2*(input.shape[dim[-1]]-1)`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `irfftn`.
            Default: ``None`` , which means transform the all dimension of `input`, or the last `len(s)` dimensions if s is given.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `irfftn()` function, result.shape[dim[i]] is s[i].
        When the input is int16, int32, int64, float16, float32 the return value type is float32.
        When the input is float64, the return value type is float64.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64, complex64, complex128.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((2, 2, 2))
        >>> ops.irfftn(input, s=(2, 2, 2), dim=(0, 1, 2), norm="backward")
        Tensor(shape=[2, 2, 2], dtype=Float32, value=
        [[[ 1.00000000e+00,  0.00000000e+00],
          [ 0.00000000e+00,  0.00000000e+00]],
         [[ 0.00000000e+00,  0.00000000e+00],
          [ 0.00000000e+00,  0.00000000e+00]]])
    """
    return irfftn_op(input, s, dim, norm)


def isfinite(x):
    r"""
    Determine which elements are finite for each position. If elements are not ``NaN`` , ``-INF`` , ``INF``,
    they are finite.

    .. math::

        out_i = \begin{cases}
          & \text{ if } x_{i} = \text{Finite},\ \ True \\
          & \text{ if } x_{i} \ne \text{Finite},\ \ False
        \end{cases}

    Args:
      x (Tensor): The input tensor.

    Returns:
        Tensor, has the same shape of input, and the dtype is bool.

    Raises:
        TypeError: If x is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([np.log(-1), 1, np.log(0)]), mindspore.float32)
        >>> output = ops.isfinite(x)
        >>> print(output)
        [False True False]
        >>> x = Tensor(2.1, mindspore.float64)
        >>> output = ops.isfinite(x)
        >>> print(output)
        True
    """
    return isfinite_op(x)


def leaky_relu_ext(input, negative_slope=0.01):
    r"""
    leaky_relu activation function. The element of `input` less than 0 times `negative_slope` .

    The activation function is defined as:

    .. math::
        \text{leaky_relu}(input) = \begin{cases}input, &\text{if } input \geq 0; \cr
        {\negative_slope} * input, &\text{otherwise.}\end{cases}

    where :math:`\negative_slope` represents the `negative_slope` parameter.

    For more details, see `Rectifier Nonlinearities Improve Neural Network Acoustic Models
    <https://ai.stanford.edu/~amaas/papers/relu_hybrid_icml2013_final.pdf>`_.

    LeakyReLU Activation Function Graph:

    .. image:: ../images/LeakyReLU.png
        :align: center

    Args:
        input (Tensor): The input of leaky_relu is a Tensor of any dimension.
        negative_slope (Union[int, float]): Slope of the activation function when the element of `input` is less than 0.
          Default: ``0.01`` .

    Returns:
        Tensor, has the same type and shape as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If `negative_slope` is not a float or an int.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([[-1.0, 4.0, -8.0], [2.0, -5.0, 9.0]]), mindspore.float32)
        >>> print(mint.leaky_relu(input, negative_slope=0.2))
        [[-0.2  4.  -1.6]
         [ 2.  -1.   9. ]]
    """
    return leaky_relu_ext_op(input, negative_slope)


def less_equal(input, other):
    r"""
    Computes the boolean value of :math:`input <= other` element-wise.

    .. math::
        out_{i} =\begin{cases}
            & \text{True,    if } input_{i}<=other_{i} \\
            & \text{False,   if } input_{i}>other_{i}
            \end{cases}

    .. note::
        - Inputs of `input` and `other` comply with the implicit type conversion rules to make the data types
          consistent.
        - When the inputs are one tensor and one scalar, the scalar could only be a constant.

    Args:
        input (Union[Tensor, Number, bool]): The first input is a Number or a bool or a tensor whose data type is 
            number or bool\_.
        other (Union[Tensor, Number, bool]): The second input is a Number or a bool or a tensor whose data type is 
            number or bool\_.

    Returns:
        Tensor, the shape is the same as the one after broadcasting, and the data type is bool.

    Raises:
        TypeError: If neither `input` nor `other` is a Tensor or number.Number.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([1, 2, 3]), mindspore.int32)
        >>> other = Tensor(np.array([1, 1, 4]), mindspore.int32)
        >>> output = ops.less_equal(x, other)
        >>> print(output)
        [ True False  True]
    """
    return less_equal_op(input, other)


def less(input, other):
    r"""
    Computes the boolean value of :math:`input < other` element-wise.

    The inputs of `input` and `other` follow implicit type conversion rules to ensure consistent data types.
    When the inputs are a Tensor and a Scalar, the Scalar can only be a constant.

    .. math::
        out_{i} =\begin{cases}
            & \text{True,    if } input_{i}<other_{i} \\
            & \text{False,   if } input_{i}>=other_{i}
            \end{cases}

    Args:
        input (Union[Tensor, Number, bool]): The first input is a number or
            a bool or a tensor whose data type is number or bool.
        other (Union[Tensor, Number, bool]): The second input is a number or
            a bool or a tensor whose data type is number or bool.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,and the data type is bool.

    Raises:
        TypeError: If `input` and `other` is not one of the following: Tensor, Number, bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1, 2, 3]), mindspore.int32)
        >>> other = Tensor(np.array([1, 1, 4]), mindspore.int32)
        >>> output = ops.less(input, other)
        >>> print(output)
        [False False True]
    """
    return less_op(input, other)


def log1p(input):
    r"""
    Returns the natural logarithm of one plus the input tensor element-wise.

    .. math::
        out_i = \{log_e}(input_i + 1)

    Args:
        input (Tensor): The input tensor. The value must be greater than -1.

    Returns:
        Tensor, has the same shape as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)
        >>> output = ops.log1p(x)
        >>> print(output)
        [0.6931472 1.0986123 1.609438 ]
    """
    return log1p_op(input)


def log(input):
    r"""
    Returns the natural logarithm of a tensor element-wise.

    .. math::
        y_i = \log_e(x_i)

    .. warning::
        If the input value of operator Log is within the range (0, 0.01] or [0.95, 1.05], the output accuracy may
        be affacted.

    Args:
        input (Tensor): Input Tensor of any dimension. The value must be greater than 0.

    Returns:
        Tensor, has the same shape and dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)
        >>> output = ops.log(x)
        >>> print(output)
        [0.        0.6931472 1.3862944]
    """
    return log_op(input)


def log_softmax(logits, axis=-1):
    r"""
    Applies the Log Softmax function to the input tensor on the specified axis.
    Supposes a slice in the given axis, :math:`x` for each element :math:`x_i`,
    the Log Softmax function is shown as follows:

    .. math::
        \text{output}(x_i) = \log \left(\frac{\exp(x_i)} {\sum_{j = 0}^{N-1}\exp(x_j)}\right),

    where :math:`N` is the length of the Tensor.

    Args:
        logits (Tensor): The input Tensor, which is the :math:`x` in the formula above, it's shape is :math:`(N, *)`, 
            where :math:`*` means, any number of additional dimensions, with float16 or float32 data type.
        axis (int): The axis to perform the Log softmax operation. Default: ``-1`` .

    Returns:
        Tensor, with the same type and shape as the logits.

    Raises:
        TypeError: If `axis` is not an int.
        TypeError: If dtype of `logits` is neither float16 nor float32.
        ValueError: If `axis` is not in range [-len(logits.shape), len(logits.shape)).
        ValueError: If dimension of `logits` is less than 1.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> logits = Tensor(np.array([1, 2, 3, 4, 5]), mindspore.float32)
        >>> output = ops.log_softmax(logits)
        >>> print(output)
        [-4.4519143 -3.4519143 -2.4519143 -1.4519144 -0.4519144]
    """
    log_softmax_op = _get_cache_prim(LogSoftmax)(axis)
    return log_softmax_op(logits)


def masked_fill(input_x, mask, value):
    r"""
    Fills elements of Tensor with value where mask is True.
    The shapes of `input_x` and `mask` need to be the same or broadcastable.

    Args:
        input_x (Tensor): The source Tensor whose data type is one of bool, uint8, int8, int16, int32,
            int64, float16, float32, float64, complex64, complex128.
        mask (Tensor[bool]): The boolean mask.
        value (Union[Number, Tensor]): The value to fill in with, which dtype is the same as `input_x`.

    Returns:
        Tensor, has the same type and shape as `input_x`.

    Raises:
        TypeError: If dtype of `mask` is not bool.
        TypeError: If `input_x` or `mask` is not a Tensor.
        ValueError: If the shapes of `input_x` and `mask` could not be broadcast.
        TypeError: If dtype of `input_x` or `value` is not one of bool, uint8, int8, int16, int32,
            int64, float16, float32, float64, complex64, complex128.
        TypeError: If dtype of `value` is different from that of `input_x`.
        TypeError: If `value` is neither float number nor Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input_x = Tensor(np.array([1., 2., 3., 4.]), mindspore.float32)
        >>> mask = Tensor(np.array([True, True, False, True]), mindspore.bool_)
        >>> output = ops.masked_fill(input_x, mask, 0.5)
        >>> print(output)
        [0.5 0.5 3.  0.5]
    """
    return masked_fill_op(input_x, mask, value)


def matmul_ext(input, mat2):
    r"""
    
    """
    return matmul_ext_op(input, mat2)


def matrix_exp(input):
    r"""
    Computes the exponential of a single or a batch of square matrices.

    .. math::

        matrix\_exp(x) = \sum_{k=0}^{\infty} \frac{1}{k !} x^{k} \in \mathbb{K}^{n \times n}

    where :math:`x` corresponds to `input` .

    Args:
        input (Tensor): The shape of tensor is :math:`(*, n, n)` where * is zero or more batch dimensions.
            Must be one of the following types: float16, float32, float64, complex64, complex128.

    Returns:
        Tensor, has the same shape and dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: If the dtype of `input` is not one of the following dtype:
                float16, float32, float64, complex64, complex128.
        ValueError: If the rank of `input` is less than 2.
        ValueError: If the size of last two dimensions of `input` are not equal.

    Supported Platforms:


    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([[1, 2], [0, 1]]), mindspore.float32)
        >>> output = ops.matrix_exp(input)
        >>> print(output)
        [[2.7182817 5.436563 ]
        [0.        2.7182817]]
    """
    return matrix_exp_op(input)


def max_(input):
    r"""
    Calculates the maximum value of the input tensor.

    Also see :func:`mindspore.ops.extend.max`.
    """
    return max_op(input)


def maximum(input, other):
    r"""
    Computes the maximum of input tensors element-wise.

    Note:
        - Inputs of `input` and `other` comply with the implicit type conversion rules to make the data types
          consistent.
        - The inputs must be two tensors or one tensor and one scalar.
        - When the inputs are two tensors,
          dtypes of them cannot be bool at the same time, and the shapes of them could be broadcast.
        - When the inputs are one tensor and one scalar,
          the scalar could only be a constant.
        - Broadcasting is supported.
        - If one of the elements being compared is a NaN, then that element is returned.

    .. math::
        output_i = \max(input_i, other_i)

    Args:
        input (Union[Tensor, Number, bool]): The first input is a number or
            a bool or a tensor whose data type is number or bool.
        other (Union[Tensor, Number, bool]): The second input is a number or
            a bool when the first input is a tensor or a tensor whose data type is number or bool.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs.

    Raises:
        TypeError: If `input` and `other` is not one of the following: Tensor, Number, bool.
        ValueError: If `input` and `other` are not the same shape.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> # case 1 : same data type
        >>> input = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.float32)
        >>> other = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)
        >>> output = ops.maximum(input, other)
        >>> print(output)
        [4. 5. 6.]
        >>> # case 2 : different data type
        >>> input = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.int32)
        >>> other = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)
        >>> output = ops.maximum(input, other)
        >>> print(output.dtype)
        Float32
    """
    return maximum_op(input, other)


def mean(input, axis=None, keep_dims=False, dtype=None):
    r"""
    Reduces all dimension of a tensor by averaging all elements in the dimension, by default.
    And reduce a dimension of `input` along the specified `axis`. `keep_dims`
    determines whether the dimensions of the output and input are the same.

    Note:
        The `axis` with tensor type is only used for compatibility with older versions and is not recommended.

    Args:
        input (Tensor[Number]): The input tensor. The dtype of the tensor to be reduced is number.
            :math:`(N, *)` where :math:`*` means, any number of additional dimensions.
        axis (Union[int, tuple(int), list(int), Tensor]): The dimensions to reduce. Default: ``None`` ,
            reduce all dimensions. Only constant value is allowed. Assume the rank of `input` is r,
            and the value range is [-r,r).
        keep_dims (bool): If ``True`` , keep these reduced dimensions and the length is 1.
            If ``False`` , don't keep these dimensions. Default: ``False`` .
        dtype (:class:`mindspore.dtype`): The desired data type of returned Tensor. Default: ``None`` .

    Returns:
        Tensor, has the same data type as input tensor.

        - If `axis` is ``None`` , and `keep_dims` is ``False`` ,
          the output is a 0-D tensor representing the product of all elements in the input tensor.
        - If `axis` is int, set as 1, and `keep_dims` is ``False`` ,
          the shape of output is :math:`(x_0, x_2, ..., x_R)`.
        - If `axis` is tuple(int), set as (1, 2), and `keep_dims` is ``False`` ,
          the shape of output is :math:`(x_0, x_3, ..., x_R)`.
        - If `axis` is 1-D Tensor, set as [1, 2], and `keep_dims` is ``False`` ,
          the shape of output is :math:`(x_0, x_3, ..., x_R)`.

    Raises:
        TypeError: If `x` is not a Tensor.
        TypeError: If `axis` is not one of the following: int, tuple, list or Tensor.
        TypeError: If `keep_dims` is not a bool.
        ValueError: If `axis` is out of range.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.random.randn(3, 4, 5, 6).astype(np.float32))
        >>> output = ops.mean(x, 1, keep_dims=True)
        >>> result = output.shape
        >>> print(result)
        (3, 1, 5, 6)
        >>> # case 1: Reduces a dimension by averaging all elements in the dimension.
        >>> x = Tensor(np.array([[[2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2]],
        ... [[4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]],
        ... [[6, 6, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8], [10, 10, 10, 10, 10, 10]]]),
        ... mindspore.float32)
        >>> output = ops.mean(x)
        >>> print(output)
        5.0
        >>> print(output.shape)
        ()
        >>> # case 2: Reduces a dimension along the axis 0
        >>> output = ops.mean(x, 0, True)
        >>> print(output)
        [[[4. 4. 4. 4. 4. 4.]
        [5. 5. 5. 5. 5. 5.]
        [6. 6. 6. 6. 6. 6.]]]
        >>> # case 3: Reduces a dimension along the axis 1
        >>> output = ops.mean(x, 1, True)
        >>> print(output)
        [[[2. 2. 2. 2. 2. 2.]]
        [[5. 5. 5. 5. 5. 5.]]
        [[8. 8. 8. 8. 8. 8.]]]
        >>> # case 4: Reduces a dimension along the axis 2
        >>> output = ops.mean(x, 2, True)
        >>> print(output)
        [[[ 2.]
        [ 2.]
        [ 2.]]
        [[ 4.]
        [ 5.]
        [ 6.]]
        [[ 6.]
        [ 8.]
        [10.]]]
    """
    return mean_ext_op(input, axis, keep_dims, dtype)


def min_(input):
    r"""
    Calculates the minimum value of the input tensor.

    Also see :func:`mindspore.ops.extend.min`.
    """
    return min_op(input)


def minimum(input, other):
    r"""
    Computes the minimum of input tensors element-wise.

    Note:
        - Inputs of `input` and `other` comply with the implicit type conversion rules to make the data types
          consistent.
        - When the inputs are two tensors, dtypes of them cannot be bool at the same time.
        - When the inputs are one tensor and one scalar, the scalar could only be a constant.
        - Shapes of them are supposed to be broadcast.
        - If one of the elements being compared is a NaN, then that element is returned.

    .. math::
        output_i = \min(input_i, other_i)

    Args:
        input (Union[Tensor, Number, bool]): The first input is a number or
            a bool or a tensor whose data type is number or bool.
        other (Union[Tensor, Number, bool]): The second input is a number or
            a bool when the first input is a tensor or a tensor whose data type is number or bool.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs.

    Raises:
        TypeError: If `input` and `other` is not one of the following: Tensor, Number, bool.
        ValueError: If `input` and `other` are not the same shape after broadcast.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> # case 1 : same data type
        >>> input = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.float32)
        >>> other = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)
        >>> output = ops.minimum(input, other)
        >>> print(output)
        [1. 2. 3.]
        >>> # case 2 : different data type
        >>> input = Tensor(np.array([1.0, 5.0, 3.0]), mindspore.int32)
        >>> other = Tensor(np.array([4.0, 2.0, 6.0]), mindspore.float32)
        >>> output = ops.minimum(input, other)
        >>> print(output.dtype)
        Float32
    """
    return minimum_op(input, other)


def moe_finalize_routing(expanded_x, x1, x2=None, bias=None, scales=None, expanded_row_idx=None,
                         expanded_expert_idx=None):
    r"""
    
    """
    return moe_finalize_routing_op(expanded_x, x1, x2, bias, scales, expanded_row_idx, expanded_expert_idx)


def mul(input, other):
    r"""
    Multiplies two tensors element-wise.

    .. math::

        out_{i} = input_{i} * other_{i}

    Note:
        - When the two inputs have different shapes,
          they must be able to broadcast to a common shape.
        - The two inputs can not be bool type at the same time,
          [True, Tensor(True, bool\_), Tensor(np.array([True]), bool\_)] are all considered bool type.
        - The two inputs comply with the implicit type conversion rules to make the data types
          consistent.

    Args:
        input (Union[Tensor, number.Number, bool]): The first input is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/r2.3/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/r2.3/api_python/mindspore.html#mindspore.dtype>`_.
        other (Union[Tensor, number.Number, bool]): The second input, which is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs.

    Raises:
        TypeError: If `input` and `other` is not one of the following: Tensor, number.Number, bool.
        ValueError: If `input` and `other` are not the same shape.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([1.0, 2.0, 3.0]), mindspore.float32)
        >>> y = Tensor(np.array([4.0, 5.0, 6.0]), mindspore.float32)
        >>> output = ops.mul(x, y)
        >>> print(output)
        [ 4. 10. 18.]
    """
    return mul_op(input, other)


def mv(input, vec):
    r"""
    
    """
    return mv_op(input, vec)


def neg(input):
    r"""
    Returns a tensor with negative values of the input tensor element-wise.

    .. math::
        out_{i} = - input_{i}

    Args:
        input (Tensor): The input tensor with a dtype of Number.

    Returns:
        Tensor, has the same shape and dtype as input.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1, 2, -1, 2, 0, -3.5]), mindspore.float32)
        >>> output = ops.neg(input)
        >>> print(output)
        [-1.  -2.   1.  -2.   0.   3.5]
    """
    return neg_op(input)


def nextafter(input, other):
    r"""
    Returns the next representable floating-point value after `input` towards `other` element-wise.

    Say there are two float32 numbers :math:`a`, :math:`b`, and let the
    representable delta of float32 datatype is :math:`eps`. If :math:`a < b`,
    then the next representable of :math:`a` towards :math:`b` is :math:`a+eps`,
    the next representable of :math:`b` towards :math:`a` is :math:`b-eps`.

    .. math::

        out_{i} =  nextafter({input_{i}, other_{i}})

    For more detailed information, refer to `A Self Regularized Non-Monotonic Neural Activation Function <https://arxiv.org/abs/1908.08681>`_.

    Args:
        input (Tensor): The first input tensor. The shape of tensor is :math:`(N,*)` where :math:`*` means,
            any number of additional dimensions. Must be one of the following types: float32, float64.

        other (Tensor): The second input tensor. The shape of tensor is :math:`(N,*)` where :math:`*` means,
            any number of additional dimensions. Must be one of the following types: float32, float64.

    Returns:
        Tensor, has the same shape and data type as `input`.

    Raises:
        TypeError: If neither `input` nor `other` is a Tensor.
        TypeError: If the dtype of `input` and `other` is not one of: float32, float64.
        TypeError: If the dtypes of `input` and `other` are not same.
        ValueError: If `input`'s shape is not the same as `other`.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input_ = Tensor(np.asarray([0.0]), mindspore.float32)
        >>> other_ = Tensor(np.asarray([0.1]), mindspore.float32)
        >>> output_ = ops.nextafter(input_, other_)
        >>> print(output_)
        [1.e-45]
    """
    return next_after_op(input, other)


def nonzero(input):
    r"""
    Return a Tensor of the positions of all non-zero values.

    Args:
        input (Tensor): The input Tensor, its rank should be greater than or eaqual to 1.

    Returns:
        Tensor, a 2-D Tensor whose data type is int64, containing the positions of all non-zero values of the input.

    Raises:
        TypeError: If `input` is not Tensor.
        ValueError: If dim of `input` equals to 0.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor
        >>> import mindspore.ops as ops
        >>> x = Tensor(np.array([[[1,  0], [-5, 0]]]), mindspore.int32)
        >>> output = ops.nonzero(x)
        >>> print(output)
        [[0 0 0]
         [0 1 0]]
        >>> x = Tensor(np.array([1, 0, 2, 0, 3]), mindspore.int32)
        >>> output = ops.nonzero(x)
        >>> print(output)
        [[0]
         [2]
         [4]]
    """
    return non_zero_op(input)


def not_equal(input, other):
    r"""
    Alias for :func:`mindspore.ops.ne` .

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``
    """
    return not_equal_op(input, other)


ones_op = Ones()


def ones(shape, dtype=None):
    r"""
    Creates a tensor filled with value ones.

    Creates a tensor with shape described by the first argument and fills it with value ones in type of the second
    argument.

    .. warning::
        For argument `shape`, Tensor type input will be deprecated in the future version.

    Args:
        shape (Union[tuple[int], list[int], int, Tensor]): The specified shape of output tensor. Only positive integer or
            tuple or Tensor containing positive integers are allowed. If it is a Tensor,
            it must be a 0-D or 1-D Tensor with int32 or int64 dtypes.
        dtype (:class:`mindspore.dtype`): The specified type of output tensor. If `dtype` is ``None`` ,
            `mindspore.float32` will be used. Default: ``None`` .

    Returns:
        Tensor, whose dtype and size are defined by input.

    Raises:
        TypeError: If `shape` is neither an int nor an tuple/list/Tensor of int.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import ops
        >>> output = ops.ones((2, 2), mindspore.float32)
        >>> print(output)
        [[1. 1.]
         [1. 1.]]
    """
    return ones_op(shape, dtype)


def paged_attention_mask(query, key_cache, value_cache, block_tables, context_lens, alibi_mask, head_num, scale_value,
                         kv_head_num):
    r"""
    The PagedAttentionMask is the fusion of block-wise KV Cache access and self-attention(with alibi-mask) computing.

    Args:
        query (Tensor): The query tensor with data type of float16.
          :math:`(num\_tokens, num\_head, head\_dim)`.
        key_cache (Tensor): The cache tensor with data type of float16.
          :math:`(num\_blocks, block\_size, num\_head, head\_dim)`.
        value_cache (Tensor): The cache tensor with data type of float16.
          :math:`(num\_blocks, block\_size, num\_head, head\_dim)`.
        block_tables (Tensor): The block mapping table with data type of int32.
          :math:`(num\_tokens, max_num_blocks_per_batch)`.
        context_lens (Tensor): The context length of each sequence with data type of int32.
          :math:`(num\_tokens,)`.
        alibi_mask (Tensor): The context length of each sequence with data type of float16.
          :math:`(num\_tokens, num\_head, 1, max\_context\_len)`.
                    
    Outputs:
        attention output.

    Notes:
        No backend implementation in MindSpore, only use to export MindIr and run in MindSpore Lite.

    Examples:
        >>> from mindspore.ops.operations import _inner_ops
        >>> num_tokens =  = 4
        >>> num_head = 40
        >>> num_kv_head = 40
        >>> head_dim = 128
        >>> block_size = 16
        >>> num_blocks = 128
        >>> max_seq = 1024
        >>> max_num_blocks_per_batch = max_seq // block_size
        >>> scale_value = 1.0 / math.sqrt(head_dim)
        >>> query = Tensor(np.random.randn(num_tokens, num_head, head_dim).astype(np.float16))
        >>> key_cache = Parameter(default_input=Tensor(np.random.randn(num_blocks, block_size, num_head, head_dim).astype(np.float16)))
        >>> value_cache = Parameter(default_input=Tensor(np.random.randn(num_blocks, block_size, num_head, head_dim).astype(np.float16)))
        >>> dummy_block_indice = np.random.shuffle(np.arange(num_tokens * max_num_blocks_per_batch, dtype=np.int32))
        >>> block_tables = Tensor(np.reshape(dummy_block_indice, (num_tokens, max_num_blocks_per_batch)))
        >>> context_lens = Tensor(np.random.randint(max_seq, size=num_tokens).astype(np.int32)))
        >>> alibi_mask = Tensor(np.random.randn(num_tokens, num_head, 1, max_seq).astype(np.int32)))
        >>> paged_attention_mask = _inner_ops.PagedAttentionMask()
        >>> output = paged_attention_mask(query, key_cache, value_cache, block_tables, context_lens, alibi_mask)
        >>> print(output)
    """
    paged_attention_mask_op = _get_cache_prim(PagedAttentionMask)(head_num, scale_value, kv_head_num)
    return paged_attention_mask_op(query, key_cache, value_cache, block_tables, context_lens, alibi_mask)


def paged_attention(query, key_cache, value_cache, block_tables, context_lens, head_num, scale_value, kv_head_num):
    r"""
    The PagedAttention is the fusion of block-wise KV Cache access and self-attention computing.

    Args:
        query (Tensor): The query tensor with data type of float16.
          :math:`(num\_tokens, num\_head, head\_dim)`.
        key_cache (Tensor): The cache tensor with data type of float16.
          :math:`(num\_blocks, block\_size, num\_head, head\_dim)`.
        value_cache (Tensor): The cache tensor with data type of float16.
          :math:`(num\_blocks, block\_size, num\_head, head\_dim)`.
        block_tables (Tensor): The block mapping table with data type of int32.
          :math:`(num\_tokens, max_num_blocks_per_batch)`.
        context_lens (Tensor): The context length of each sequence with data type of int32.
          :math:`(num\_tokens,)`.
                    
    Outputs:
        attention output.

    Notes:
        No backend implementation in MindSpore, only use to export MindIr and run in MindSpore Lite.

    Examples:
        >>> from mindspore.ops.operations import _inner_ops
        >>> num_tokens =  = 4
        >>> num_head = 40
        >>> num_kv_head = 40
        >>> head_dim = 128
        >>> block_size = 16
        >>> num_blocks = 128
        >>> max_seq = 1024
        >>> max_num_blocks_per_batch = max_seq // block_size
        >>> scale_value = 1.0 / math.sqrt(head_dim)
        >>> query = Tensor(np.random.randn(num_tokens, num_head, head_dim).astype(np.float16))
        >>> key_cache = Parameter(default_input=Tensor(np.random.randn(num_blocks, block_size, num_head, head_dim).astype(np.float16)))
        >>> value_cache = Parameter(default_input=Tensor(np.random.randn(num_blocks, block_size, num_head, head_dim).astype(np.float16)))
        >>> dummy_block_indice = np.random.shuffle(np.arange(num_tokens * max_num_blocks_per_batch, dtype=np.int32))
        >>> block_tables = Tensor(np.reshape(dummy_block_indice, (num_tokens, max_num_blocks_per_batch)))
        >>> context_lens = Tensor(np.random.randint(max_seq, size=num_tokens).astype(np.int32)))
        >>> paged_attention = _inner_ops.PagedAttention()
        >>> output = paged_attention(query, key_cache, value_cache, block_tables, context_lens)
        >>> print(output)
    """
    paged_attention_op = _get_cache_prim(PagedAttention)(head_num, scale_value, kv_head_num)
    return paged_attention_op(query, key_cache, value_cache, block_tables, context_lens)


def pow(input, exponent):
    r"""
    Calculates the `exponent` power of each element in `input`.

    When `exponent` is a Tensor, the shapes of `input` and `exponent` must be broadcastable.

    .. math::

        out_{i} = input_{i} ^{ exponent_{i}}

    Args:
        input (Union[Tensor, Number]): The first input is a Number or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.
        exponent (Union[Tensor, Number]): The second input is a Number or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)
        >>> exponent = 3.0
        >>> output = ops.pow(input, exponent)
        >>> print(output)
        [ 1.  8. 64.]
        >>>
        >>> input = Tensor(np.array([1.0, 2.0, 4.0]), mindspore.float32)
        >>> exponent = Tensor(np.array([2.0, 4.0, 3.0]), mindspore.float32)
        >>> output = ops.pow(input, exponent)
        >>> print(output)
        [ 1. 16. 64.]
    """
    return pow_op(input, exponent)


def prelu(x, weight):
    r"""
    Parametric Rectified Linear Unit activation function.

    PReLU is described in the paper `Delving Deep into Rectifiers: Surpassing Human-Level Performance on
    ImageNet Classification <https://arxiv.org/abs/1502.01852>`_. Defined as follows:

    .. math::
        prelu(x_i)= \max(0, x_i) + \min(0, w * x_i),

    where :math:`x_i` is an element of a channel of the input, `w` is the weight of the channel.

    Note:
        Scalar or 1-D Tensor is not supported on Ascend.

    PReLU Activation Function Graph:

    .. image:: ../images/PReLU.png
        :align: center

    Args:
        x (Tensor): The input Tensor of the activation function. The data type is float16 or float32.
            The shape is :math:`(N, *)` where :math:`*` means, any number of additional dimensions.
        weight (Tensor):  Weight Tensor. The data type is float16 or float32.
            The weight can only be a Tensor, and the length is the same as the number of channels C of the `input_x`.
            On GPU devices, when the input is a scalar, the shape is :math:`(1,)` .

    Returns:
        Tensor, with the same shape and dtype as `x`.
        For detailed information, please refer to :class:`mindspore.nn.PReLU`.

    Raises:
        TypeError: If dtype of `x` or `weight` is neither float16 nor float32.
        TypeError: If the `x` or the `weight` is not a Tensor.
        ValueError: If the `x` is a 0-D or 1-D Tensor on Ascend.
        ValueError: If the `weight` is not a 1-D Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.arange(-6, 6).reshape((2, 3, 2)), mindspore.float32)
        >>> weight = Tensor(np.array([0.1, 0.6, -0.3]), mindspore.float32)
        >>> output = ops.prelu(x, weight)
        >>> print(output)
        [[[-0.60 -0.50]
          [-2.40 -1.80]
          [ 0.60  0.30]]
         [[ 0.00  1.00]
          [ 2.00  3.00]
          [ 4.0   5.00]]]
    """
    return prelu_op(x, weight)


def prompt_k_v_cache(cache, update, valid_seq_len, batch_index, seq_len_axis, new_max_seq_len, cur_max_seq_len,
                     align_mode='LEFT'):
    r"""
    The PromptKVCache is used for prefill the KVCache of transformer network.

    Args:
        cache (Tensor): The cahe tensor with data type of int8, uint8, int16, uint16, float16, float32 and int32.
          When format is BHSD, cache tensor of shape
          :math:`(cache\_batch\_size, num\_head, max\_seq\_length, size\_pre\_head)`.
          When format is BSD, cache tensor of shape
          :math:`(cache\_batch\_size, max\_seq\_length, hidden\_size)`.
        update (Tensor]): The tensor which is used to update the cache tensor. Same data type as cache tensor.
          When format is BHSD, cache tensor of shape
          :math:`(update\_batch\_size, num\_head, max\_seq\_length, size\_pre\_head)`.
          When format is BSD, cache tensor of shape
          :math:`(update\_batch\_size, max\_seq\_length, hidden\_size)`.
        valid_seq_len (Tensor): The valid_seq_len tensor with data type of int64.
          Valid_seq_len tensor of shape :math:`(update\_batch\_size)`.
        batch_index (Tensor): The batch_index tensor with data type of int64.
          Batch_index tensor of shape :math:`(update\_batch\_size)`. Indicate that which batch of cache tensor is going to be update.
        seq_len_axis (Tensor): The seq_len_axis indicate which axis is seq_eln, set to '1' or '2'. Not able for now.
        new_max_seq_len (Tensor): The new_max_seq_len tensor with data type of int64.
          New_max_seq_len tensor of shape :math:`(1)`.
          Indicate that user want to change the shape of cache tensor from
          :math:`(batch\_size, num_head, max\_seq\_length, hidden\_size)` to
          :math:`(batch\_size * max\_seq\_length / new\_max\_seq\_length, num_head, new\_max\_seq\_length, hidden\_size)`
          to update the cache tensor. This will not real change the shape of `cache` tensor. Not able for now.
        cur_max_seq_len (Tensor): The new_max_seq_len tensor with data type of int64.
          Cur_max_seq_len tensor of shape :math:`(1)`. Keep the current seq_len of cache tensor. Not abel for now.
        align_mode (str): indicate which axis is seq_len. Default: left.


    Outputs:
        With same data type and same shape as `cache` tensor.

    Supported Platforms:
        ``Ascend``

    Examples:
        >>> from mindspore import Tensor
        >>> from mindspore.ops.operations import _inner_ops
        >>> b = 4
        >>> h = 40
        >>> max_s = 1024
        >>> s = 256
        >>> d = 128
        >>> cache = Tensor(np.random.randn(b, h, max_s, d).astype(np.float16))
        >>> update = Tensor(np.random.randn(b, h, s, d).astype(np.float16))
        >>> valid_seq_len = Tensor(np.random.randint(-1, s, size=ub).astype(np.int64))
        >>> batch_index = Tensor(np.random.choice(np.arange(-1, b), size=ub, replace=False).astype(np.int64))
        >>> new_max_seq_len = Tensor(np.random.randn(1).astype(np.int64))
        >>> cur_max_seq_len = Tensor(np.random.randn(1).astype(np.int64))
        >>> prompt_kv_cache = _inner_ops.PromptKVCache(0)
        >>> output = prompt_kv_cache(cache, update, valid_seq_len, batch_index, Tensor(2), new_max_seq_len, cur_max_seq_len)
        >>> print(cache)
    """
    prompt_k_v_cache_op = _get_cache_prim(PromptKVCache)(align_mode)
    return prompt_k_v_cache_op(cache, update, valid_seq_len, batch_index, seq_len_axis, new_max_seq_len,
                               cur_max_seq_len)


def quant_batch_matmul(x1, x2, scale, offset=None, bias=None, transpose_x1=False, transpose_x2=False,
                       dtype=mstype.float16):
    r"""
    
    """
    return quant_batch_matmul_impl(x1, x2, scale, offset, bias, transpose_x1, transpose_x2, dtype)


def randperm(n, seed=0, offset=0, dtype=mstype.int64):
    r"""
    Generates random permutation of integers from 0 to n-1.

    Returns the tensor with the determined shape inferred by n, the random numbers in it drawn from the data range
    that a given type can represent.

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        n (Union[Tensor, int]): The input n Tensor with shape: () or (1,) and with data type of int64.
            The value of `n` must be greater than zero.
        seed (int, optional): Random seed. Default: ``0`` . When seed is -1(only negative value), offset is 0,
            it's determined by time.
        offset (int, optional): Offset to generate random numbers. Priority is higher than random seed.
            Default: ``0`` . It must be non-negative.
        dtype (mindspore.dtype, optional): The type of output.
            Its value must be one of the following types: int32, int16, int8,
            uint8, int64, float64, float32, float16. Default: ``mstype.int64``.

    Returns:
        Tensor. Its shape is specified by the required args `n`. Its type is specified by `dtype`.
        Otherwise is default.

    Raises:
        TypeError: If `dtype` is not allowed.
        ValueError: If `n` is a negative or 0 element.
        ValueError: If `seed` is a negative element.
        ValueError: If `n` is larger than the maximal data of the set dtype.

    Supported Platforms:
        ``CPU``

    Examples:
        >>> from mindspore import ops
        >>> from mindspore import dtype as mstype
        >>> n = 4
        >>> seed = 0
        >>> offset = 0
        >>> output = ops.randperm(n, seed, offset, dtype=mstype.int64)
        >>> print(output)
        [0 2 1 3]
    """
    randperm_v2_op = _get_cache_prim(RandpermV2)(seed, offset, dtype)
    return randperm_v2_op(n)


def range(start, end, step, maxlen=1000000):
    r"""
    Creates a sequence of numbers that begins at `start` and extends by increments of
    `step` up to but not including `end`.

    The types of all 3 inputs must be all integers or floating-point numbers.

    Args:
        start (number): The first number in the sequence. Must have
            type: int32 ,int64, float32 or float64.
        end (number): Upper end of the sequence, exclusive. Must
            have type: int32 ,int64, float32 or float64.
        step (number): Number that increments `start`. Must have
            type: int32 ,int64, float32 or float64.
        maxlen (int, optional): Memory that can fit `maxlen` many elements
            will be allocated for the output. Optional, must be positive. Default: 1000000.
            If the output has more than `maxlen` elements, a runtime error will occur.

    Returns:
        A 1-D Tensor. If `start`, `end` and `step` are all integers, the type of output is int64.
        If `start`, `end` and `step` are all floating-point numbers, the type of output is float32.

    Raises:
        TypeError: If `start`, `end`, `step` have both integers and floating-point numbers.
        TypeError: If datatype of `start`, `end` or `step` is not supported.
        ValueError: If `step` = 0.
        ValueError: If `start` >= `end` when `step` > 0.
        ValueError: If `start` <= `end` when `step` < 0.

    Supported Platforms:
        ``GPU`` ``CPU``

    Examples:
        >>> from mindspore import ops
        >>> start = 0
        >>> end = 10
        >>> step = 4
        >>> output = ops.range(start, end, step)
        >>> print(output)
        [0 4 8]
    """
    range_op = _get_cache_prim(Range)(maxlen)
    return range_op(start, end, step)


def real(input):
    r"""
    Returns a Tensor that is the real part of the input. If input is real, it is returned unchanged.

    Args:
        input (Tensor): The input tensor to compute to.

    Returns:
        Tensor, the shape is the same as the input.

    Raises:
        TypeError: If input is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore as ms
        >>> import mindspore.ops as ops
        >>> import numpy as np
        >>> input = ms.Tensor(np.asarray(np.complex(1.3+0.4j)), ms.complex64)
        >>> output = ops.real(input)
        >>> print(output)
        1.3
    """
    return real_op(input)


def all(input, axis=None, keep_dims=False):
    r"""
    Reduces a dimension of `input` by the "logical AND" of all elements in the dimension, by default. And also can
    reduce a dimension of `input` along the `axis`. Determine whether the dimensions of the output and input are the
    same by controlling `keep_dims`.

    Note:
        The `axis` with tensor type is only used for compatibility with older versions and is not recommended.

    Args:
        input (Tensor): Input Tensor, has the shape :math:`(N, *)` where :math:`*` means,
            any number of additional dimensions.
        axis (Union[int, tuple(int), list(int), Tensor], optional): The dimensions to reduce.
            Suppose the rank of `input` is r, `axis` must be in the range [-rank(input), rank(input)).
            Default: ``None`` , all dimensions are reduced.
        keep_dims (bool, optional): If ``True`` , keep these reduced dimensions and the length is 1.
            If ``False`` , don't keep these dimensions. Default : ``False`` .

    Returns:
        Tensor, the dtype is bool.

        - If `axis` is ``None`` , and `keep_dims` is ``False`` ,
          the output is a 0-D Tensor representing the "logical AND" of all elements in the input Tensor.
        - If `axis` is int, such as 2, and `keep_dims` is ``False`` ,
          the shape of output is :math:`(input_1, input_3, ..., input_R)`.
        - If `axis` is tuple(int), such as (2, 3), and `keep_dims` is ``False`` ,
          the shape of output is :math:`(input_1, input_4, ..., input_R)`.
        - If `axis` is 1-D Tensor, such as [2, 3], and `keep_dims` is ``False`` ,
          the shape of output is :math:`(input_1, input_4, ..., input_R)`.

    Raises:
        TypeError: If `keep_dims` is not a bool.
        TypeError: If `input` is not a Tensor.
        TypeError: If `axis` is not one of the following: int, tuple, list or Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[True, False], [True, True]]))
        >>> # case 1: Reduces a dimension by the "logicalAND" of all elements in the dimension.
        >>> output = ops.all(x, keep_dims=True)
        >>> print(output)
        [[False]]
        >>> print(output.shape)
        (1, 1)
        >>> # case 2: Reduces a dimension along axis 0.
        >>> output = ops.all(x, axis=0)
        >>> print(output)
        [ True False]
        >>> # case 3: Reduces a dimension along axis 1.
        >>> output = ops.all(x, axis=1)
        >>> print(output)
        [False True]
    """
    return reduce_all_impl(input, axis, keep_dims)


def relu6(x):
    r"""
    Computes ReLU (Rectified Linear Unit) upper bounded by 6 of input tensors element-wise.

    .. math::

        \text{ReLU6}(x) = \min(\max(0,x), 6)

    It returns :math:`\min(\max(0,x), 6)` element-wise.

    ReLU6 Activation Function Graph:

    .. image:: ../images/ReLU6.png
        :align: center

    Args:
        x (Tensor): Tensor of shape :math:`(N, *)`, where :math:`*` means any number of additional dimensions.
            Data type must be float16, float32.

    Returns:
        Tensor, with the same dtype and shape as the `x`.

    Raises:
        TypeError: If dtype of `x` is neither float16 nor float32.
        TypeError: If `x` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[-1.0, 4.0, -8.0], [2.0, -5.0, 9.0]]), mindspore.float32)
        >>> result = ops.relu6(x)
        >>> print(result)
        [[0. 4. 0.]
         [2. 0. 6.]]
    """
    return relu6_op(x)


def relu(input):
    r"""
    Computes ReLU (Rectified Linear Unit activation function) of input tensors element-wise.

    It returns :math:`\max(input,\  0)` element-wise. Specially, the neurons with the negative output
    will be suppressed and the active neurons will stay the same.

    .. math::

        ReLU(input) = (input)^+ = \max(0, input)

    ReLU Activation Function Graph:

    .. image:: ../images/ReLU.png
        :align: center

    Args:
        input (Tensor): The input Tensor.

    Returns:
        Tensor, with the same dtype and shape as the `input`.

    Raises:
        TypeError: If dtype of `input` is not Number type.
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([[-1.0, 4.0, -8.0], [2.0, -5.0, 9.0]]), mindspore.float32)
        >>> output = ops.relu(input)
        >>> print(output)
        [[0. 4. 0.]
         [2. 0. 9.]]
    """
    return relu_op(input)


def repeat_interleave(input, repeats, axis=None, output_size=None):
    r"""
    
    """
    return repeat_interleave_op(input, repeats, axis, output_size)


def reshape_and_cache(key, value, key_cache, value_cache, slot_mapping):
    r"""
    The ReshapeAndCache is used for updating the block-wise KVCache of transformer network.

    Args:
        key (Tensor): The key tensor with data type of float16.
          :math:`(num\_tokens, num\_head, head\_dim)`.
        value (Tensor): The value tensor with data type of float16.
          :math:`(num\_tokens, num\_head, head\_dim)`.
        key_cache (Tensor): The cache tensor with data type of float16.
          :math:`(num\_blocks, block\_size, num\_head, head\_dim)`.
        value_cache (Tensor): The cache tensor with data type of float16.
          :math:`(num\_blocks, block\_size, num\_head, head\_dim)`.
        slot_mapping (Tensor): The slot mapping tensor with data type of int32.
          :math:`(num\_tokens,)`.
                    
    Outputs:
        With same data type and same shape as `key` tensor.

    Notes:
        No backend implementation in MindSpore, only use to export MindIr and run in MindSpore Lite.

    Examples:
        >>> from mindspore.ops.operations import _inner_ops
        >>> num_tokens =  = 4
        >>> num_head = 40
        >>> head_dim = 128
        >>> block_size = 16
        >>> num_blocks = 128
        >>> key = Tensor(np.random.randn(num_tokens, num_head, head_dim).astype(np.float16))
        >>> value = Tensor(np.random.randn(num_tokens, num_head, head_dim).astype(np.float16))
        >>> key_cache = Parameter(default_input=Tensor(np.random.randn(num_blocks, block_size, num_head, head_dim).astype(np.float16)))
        >>> value_cache = Parameter(default_input=Tensor(np.random.randn(num_blocks, block_size, num_head, head_dim).astype(np.float16)))
        >>> slot_mapping = Tensor(np.random.shuffle(np.arange(num_tokens, dtype=np.int32)))
        >>> reshape_and_cache = _inner_ops.ReshapAndCache()
        >>> output = reshape_and_cache(key, value, key_cache, value_cache, slot_mapping)
        >>> print(key_cache)
    """
    return reshape_and_cache_op(key, value, key_cache, value_cache, slot_mapping)


def reshape(input, shape):
    r"""
    Rearranges the input Tensor based on the given shape.

    The `shape` can only have one -1 at most, in which case it's inferred from the remaining dimensions and
    the number of elements in the input.

    Args:
        input (Tensor): The shape of tensor is :math:`(x_1, x_2, ..., x_R)`.
        shape (Union[tuple[int], list[int], Tensor[int]]): If `shape` is a tuple or list, its elements should be
            integers, and only constant value is allowed. i.e., :math:`(y_1, y_2, ..., y_S)`. If `shape` is a Tensor,
            data type should be int32 or int64, and only one-dimensional tensor is supported.

    Returns:
        Tensor, If the given `shape` does not contain -1, the `shape` of tensor is :math:`(y_1, y_2, ..., y_S)`.
        If the k-th position in the given `shape` is -1, the `shape` of tensor is :math:`(y_1, ..., y_{k-1},
        \frac{\prod_{i=1}^{R}x_{i}}{y_1\times ...\times y_{k-1}\times y_{k+1}\times...\times y_S} , y_{k+1}, ..., y_S)`

    Raises:
        ValueError: The given `shape` contains more than one -1.
        ValueError: The given `shape` contains elements less than -1.
        ValueError: For scenarios where the given `shape` does not contain -1, the product of elements of the given
            `shape` is not equal to the product of the input's `shape`,
            :math:`\prod_{i=1}^{R}x_{i} \ne \prod_{i=1}^{S}y_{i}`, (Namely, it does not match the input's array size).
            And for scenarios where the given `shape` contains -1, the product of elements other than -1 of the given
            `shape` is an aliquant part of the product of the input's `shape` :math:`\prod_{i=1}^{R}x_{i}`.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([[-0.1, 0.3, 3.6], [0.4, 0.5, -3.2]]), mindspore.float32)
        >>> output = ops.reshape(input, (3, 2))
        >>> print(output)
        [[-0.1  0.3]
         [ 3.6  0.4]
         [ 0.5 -3.2]]
    """
    return reshape_op(input, shape)


def flip(input, axis):
    r"""
    Reverses specific dimensions of a tensor.

    .. warning::
        The value range of "axis" is [-dims, dims - 1]. "dims" is the dimension length of "input".

    Args:
        input (Tensor): The target tensor.
            The shape is :math:`(N, *)` where :math:`*` means, any number of additional dimensions.
        axis (Union[tuple(int), list(int)]): The indices of the dimensions to reverse.

    Outputs:
        Tensor, has the same shape and type as `input`.

    Raises:
        TypeError: If `axis` is neither list nor tuple.
        TypeError: If element of `axis` is not an int.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input_x = Tensor(np.array([[1, 2, 3, 4], [5, 6, 7, 8]]), mindspore.int32)
        >>> output = ops.flip(input_x, axis=[1])
        >>> print(output)
        [[4 3 2 1]
         [8 7 6 5]]
        >>> input_x = Tensor(np.array([[1, 2, 3, 4], [5, 6, 7, 8]]), mindspore.int32)
        >>> output = ops.flip(input_x, axis=[1, 0])
        >>> print(output)
        [[8 7 6 5]
         [4 3 2 1]]
    """
    return reverse_v2_impl(input, axis)


def rfft2(input, s=None, dim=(-2, -1), norm=None):
    r"""
    Calculates the two dimensional discrete Fourier transform for real input `input`.

    Note:
        - `rfft2` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `rfft2` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `rfft2`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `rfft2`.
            Default: ``(-2, -1)`` , which means transform the last two dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `rfft2()` function, result.shape[dim[i]] is s[i], and for the last transformed dim, 
        result.shape[dim[-1]] is :math:`s[-1] // 2 + 1`.
        When the input is int16, int32, int64, float16, float32, the return value type is complex64.
        When the input is float64, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((2, 2))
        >>> ops.rfft2(input, s=(2, 2), dim=(0, 1), norm="backward")
        Tensor(shape=[2, 2], dtype=Complex64, value=
        [[4+0j, 0+0j],
         [0+0j, 0+0j]])
    """
    return rfft2_op(input, s, dim, norm)


def rfft(input, n=None, dim=-1, norm=None):
    r"""
    Calculates the one dimensional discrete Fourier transform for real input `input`.

    Note:
        - `rfft` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `rfft` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
        n (int, optional): Number of points along `dim` in the input to use. 
            If given, the input will either be zero-padded or trimmed to this length before computing `rfft`.
            Default: ``None``.
        dim (int, optional): The dimension along which to take the one dimensional `rfft`.
            Default: ``-1``, which means transform the last dimension of `input`.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"``.
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, the result of `rfft()` function, dtype of the result is complex64/128, result.shape[dim] 
        is :math:`n // 2 + 1`.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int16, int32, int64, float32, float64.
        TypeError: If `n` or `dim` type is not int.
        ValueError: If `dim` is not in the range of :math:`[-input.ndim, -input.ndim)`.
        ValueError: If `n` is less than 1.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"``.

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = Tensor([1, 2, 3, 4])
        >>> y = ops.rfft(input, n=4, dim=-1, norm='backward')
        >>> print(y)
        [10.+0.j -2.+2.j -2.+0.j]
    """
    return rfft_op(input, n, dim, norm)


def rfftn(input, s=None, dim=None, norm=None):
    r"""
    Computes the N dimensional discrete Fourier transform for real input `input`.

    Note:
        - `rfftn` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `rfftn` is not supported on Windows platform yet.

    Args:
        input (Tensor): The input tensor.
            Supported dtypes:

            - Ascend/CPU: int16, int32, int64, float16, float32, float64.

        s (tuple[int], optional): Length of the transformed `dim` of the result.
            If given, the size of the `dim[i]` axis will be zero-padded or truncated to `s[i]` before calculating `rfftn`.
            Default: ``None`` , which does not need to process `input`.
        dim (tuple[int], optional): The dimension along which to take the one dimensional `rfftn`.
            Default: ``None`` , which means transform the all dimension of `input`, or the last `len(s)` dimensions if s is given.
        norm (str, optional): Normalization mode. Default: ``None`` that means ``"backward"`` .
            Three modes are defined as,

            - ``"backward"`` (no normalization).
            - ``"forward"`` (normalize by :math:`1/n`).
            - ``"ortho"`` (normalize by :math:`1/\sqrt{n}`).

    Returns:
        Tensor, The result of `rfftn()` function, result.shape[dim[i]] is s[i], and for the last transformed dim, 
        result.shape[dim[-1]] is :math:`s[-1] // 2 + 1`.
        When the input is int16, int32, int64, float16, float32 the return value type is complex64.
        When the input is float64, the return value type is complex128.

    Raises:
        TypeError: If the `input` type is not Tensor.
        TypeError: If the `input` data type is not one of: int32, int64, float32, float64.
        TypeError: If the type/dtype of `s` and `dim` is not int.
        ValueError: If `dim` is not in the range of "[ `-input.ndim` , `input.ndim` )".
        ValueError: If `dim` has duplicate values.
        ValueError: If `s` is less than 1.
        ValueError: If `s` and `dim` are given but have different shapes.
        ValueError: If `norm` is none of ``"backward"`` , ``"forward"`` or ``"ortho"`` .

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input = ops.ones((2, 2, 2))
        >>> ops.rfftn(input, s=(2, 2, 2), dim=(0, 1, 2), norm="backward")
        Tensor(shape=[2, 2, 2], dtype=Complex64, value=
        [[[8+0j, 0+0j],
          [0+0j, 0+0j]],
         [[0+0j, 0+0j],
          [0+0j, 0+0j]]])
    """
    return rfftn_op(input, s, dim, norm)


def round(input):
    r"""
    Returns half to even of a tensor element-wise.

    .. math::

        out_i \approx input_i

    Args:
        input (Tensor): The input tensor.

    Returns:
        Tensor, has the same shape and type as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.8, 1.5, 2.3, 2.5, -4.5]), mindspore.float32)
        >>> output = ops.round(input)
        >>> print(output)
        [ 1.  2.  2.  2. -4.]
    """
    return round_op(input)


def rsqrt(input):
    r"""
    Computes reciprocal of square root of input tensor element-wise.

    .. math::

        out_{i} =  \frac{1}{\sqrt{input_{i}}}

    Args:
        input (Tensor): The input of rsqrt. Its each element must be a non-negative
            number, if an element is negative, the calculation result is nan.

    Returns:
        Tensor, has the same shape and dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore as ms
        >>> import mindspore.ops as ops
        >>> input = ms.Tensor([-0.0370,  0.2970,  1.5420, -0.9105])
        >>> output = ops.rsqrt(input)
        >>> print(output)
        [       nan 1.8349396  0.80530024        nan]
    """
    return rsqrt_op(input)


def scalar_cast(input_x, input_y):
    r"""
    The interface is deprecated from version 2.3 and will be removed in a future version,
    please use the `int(x)` or `float(x)` instead.

    Casts the input scalar to another type.

    Args:
        input_x (scalar): The input scalar. Only constant value is allowed.
        input_y (mindspore.dtype): The type to be cast. Only constant value is allowed. And the value should only be mindspore.int64, mindspore.float64, or mindspore.bool_.

    Returns:
        Scalar. The type is the same as the python type corresponding to `input_y`.

    Raises:
        ValueError: if input_y's value is invalid.

    Supported Platforms:
        Deprecated

    Examples:
        >>> import mindspore
        >>> from mindspore import ops
        >>> output = ops.scalar_cast(255.0, mindspore.int64)
        >>> print(output)
        255
    """
    return scalar_cast_op(input_x, input_y)


scalar_to_tensor_op = ScalarToTensor()


def scalar_to_tensor(input_x, dtype=None):
    r"""
    
    """
    return scalar_to_tensor_op(input_x, dtype)


def scatter_nd(indices, updates, shape):
    r"""
    Scatters a tensor into a new tensor depending on the specified indices.

    Creates an empty tensor with the given `shape`, and set values by scattering the update tensor
    depending on indices. The empty tensor has rank :math:`P` and `indices` has rank :math:`Q`.

    The `shape` is :math:`(s_0, s_1, ..., s_{P-1})`, where :math:`P \ge 1`.

    `indices` has shape :math:`(i_0, i_1, ..., i_{Q-2}, N)`, where :math:`Q \ge 2` and :math:`N \le P`.

    The last dimension of `indices` (with length :math:`N` ) indicates slices along the :math:`N` th dimension of the
    empty tensor.

    `updates` is a tensor of rank :math:`Q-1+P-N`, and
    its shape is :math:`(i_0, i_1, ..., i_{Q-2}, s_N, s_{N+1}, ..., s_{P-1})`.

    If `indices` contains duplicates, the duplicate `updates` are summed.

    The following figure shows the calculation process of inserting two new value matrices into the first dimension
    with rank-3:

    .. image:: ScatterNd.png

    Args:
        indices (Tensor): Define the index of scattering in the new tensor with int32 or int64 data type.
            The rank of `indices` must be at least 2 and `indices.shape[-1] <= len(shape)`.
        updates (Tensor): Define the source Tensor to be updated.
            It has shape `indices.shape[:-1] + shape[indices.shape[-1]:]`.
        shape (tuple[int]): Define the shape of the output tensor, has the same data type as indices.
            `shape` can not be empty, and the elements in `shape` must be greater than or equal to 1.

    Returns:
        Tensor, the new tensor, has the same type as `update` and the same shape as `shape`.

    Raises:
        TypeError: If `shape` is not a tuple.
        ValueError: If any element of `shape` is less than 1.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> indices = Tensor(np.array([[0], [2]]), mindspore.int32)
        >>> updates = Tensor(np.array([[[1, 1, 1, 1], [2, 2, 2, 2],
        ...                             [3, 3, 3, 3], [4, 4, 4, 4]],
        ...                            [[1, 1, 1, 1], [2, 2, 2, 2],
        ...                             [3, 3, 3, 3], [4, 4, 4, 4]]]), mindspore.float32)
        >>> shape = (4, 4, 4)
        >>> output = ops.scatter_nd(indices, updates, shape)
        >>> print(output)
        [[[1. 1. 1. 1.]
          [2. 2. 2. 2.]
          [3. 3. 3. 3.]
          [4. 4. 4. 4.]]
         [[0. 0. 0. 0.]
          [0. 0. 0. 0.]
          [0. 0. 0. 0.]
          [0. 0. 0. 0.]]
         [[1. 1. 1. 1.]
          [2. 2. 2. 2.]
          [3. 3. 3. 3.]
          [4. 4. 4. 4.]]
         [[0. 0. 0. 0.]
          [0. 0. 0. 0.]
          [0. 0. 0. 0.]
          [0. 0. 0. 0.]]]
        >>> indices = Tensor(np.array([[0, 1], [1, 1]]), mindspore.int32)
        >>> updates = Tensor(np.array([3.2, 1.1]), mindspore.float32)
        >>> shape = (3, 3)
        >>> output = ops.scatter_nd(indices, updates, shape)
        >>> # In order to facilitate understanding, explain the operator pseudo-operation process step by step:
        >>> # Step 1: Generate an empty Tensor of the specified shape according to the shape
        >>> # [
        >>> #     [0. 0. 0.]
        >>> #     [0. 0. 0.]
        >>> #     [0. 0. 0.]
        >>> # ]
        >>> # Step 2: Modify the data at the specified location according to the indicators
        >>> # 0th row of indices is [0, 1], 0th row of updates is 3.2.
        >>> # means that the empty tensor in the 0th row and 1st col set to 3.2
        >>> # [
        >>> #     [0. 3.2. 0.]
        >>> #     [0. 0.   0.]
        >>> #     [0. 0.   0.]
        >>> # ]
        >>> # 1th row of indices is [1, 1], 1th row of updates is 1.1.
        >>> # means that the empty tensor in the 1th row and 1st col set to 1.1
        >>> # [
        >>> #     [0. 3.2. 0.]
        >>> #     [0. 1.1  0.]
        >>> #     [0. 0.   0.]
        >>> # ]
        >>> # The final result is as follows:
        >>> print(output)
        [[0. 3.2 0.]
         [0. 1.1 0.]
         [0. 0.  0.]]
    """
    return scatter_nd_op(indices, updates, shape)


def select(condition, input, other):
    r"""
    The conditional tensor determines whether the corresponding element in the output must be
    selected from `input` (if True) or `other` (if False) based on the value of each
    element.

    It can be defined as:

    .. math::
        out_i = \begin{cases}
        input_i, & \text{if } condition_i \\
        other_i, & \text{otherwise}
        \end{cases}

    Args:
        condition (Tensor[bool]): The condition tensor, decides which element is chosen.
            The shape is :math:`(x_1, x_2, ..., x_N, ..., x_R)`.
        input (Tensor): The first Tensor to be selected.
            If input is a Tensor, its shape should be or be braodcast to :math:`(x_1, x_2, ..., x_N, ..., x_R)`.
            If input is int or float, it will be casted to int32 or float32, and broadcast to the same shape as y.
            There must be at least one Tensor between x and y.
        other (Tensor): The second Tensor to be selected.
            If input is a Tensor, its shape should be or be braodcast to :math:`(x_1, x_2, ..., x_N, ..., x_R)`.
            If input is int or float, it will be casted to int32 or float32, and broadcast to the same shape as y.
            There must be at least one Tensor between x and y.

    Returns:
        Tensor, has the same shape as `condition`.

    Raises:
        TypeError: If input or other is not a Tensor.
        ValueError: The shape of inputs cannot be broadcast.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> # Both inputs are Tensor
        >>> cond = Tensor([True, False])
        >>> x = Tensor([2,3], mindspore.float32)
        >>> y = Tensor([1,2], mindspore.float32)
        >>> output = ops.select(cond, x, y)
        >>> print(output)
        [2. 2.]
        
    """
    return select_op(condition, input, other)


def sequence_concat(x, axis=0):
    r"""
    Support sequence Concat operation.

    .. note::
        This is only for internal used.

    Args:
        axis (Int): The axis to be concat.

    Inputs:
        - **sequence** (Union[List, Tuple]) - A sequence of Tensor objects with same shape and type..

    Outputs:
        The concat of all input.

    Raises:
        TypeError: The 'sequence' is not list or tuple.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``
    """
    sequence_concat_op = _get_cache_prim(SequenceConcat)(axis)
    return sequence_concat_op(x)


def sigmoid(input):
    r"""
    Computes Sigmoid of input element-wise. The Sigmoid function is defined as:

    .. math::

        \text{sigmoid}(x_i) = \frac{1}{1 + \exp(-x_i)}

    where :math:`x_i` is an element of `x`.

    Sigmoid Function Graph:

    .. image:: ../images/Sigmoid.png
        :align: center

    Args:
        input (Tensor): `input` is :math:`x` in the preceding formula. Tensor of any dimension,
            the data type is float16, float32, float64, complex64 or complex128.

    Returns:
        Tensor, with the same type and shape as the input.

    Raises:
        TypeError: If dtype of `input` is not float16, float32, float64, complex64 or complex128.
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1, 2, 3, 4, 5]), mindspore.float32)
        >>> output = ops.sigmoid(input)
        >>> print(output)
        [0.7310586  0.880797   0.95257413 0.98201376 0.9933072 ]
    """
    return sigmoid_op(input)


def silu(input):
    r"""
    Computes Sigmoid Linear Unit of input element-wise. The SiLU function is defined as:

    .. math::

        \text{SiLU}(x) = x * \sigma(x),

    where :math:`x` is an element of the input, :math:`\sigma(x)` is Sigmoid function.

    .. math::

        \text{sigma}(x_i) = \frac{1}{1 + \exp(-x_i)},

    SiLU Function Graph:

    .. image:: ../images/SiLU.png
        :align: center

    Args:
        input (Tensor): `input` is :math:`x` in the preceding formula. Input with the data type
            float16 or float32.

    Returns:
        Tensor, with the same type and shape as the `input`.

    Raises:
        TypeError: If dtype of `input` is neither float16 nor float32.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> import numpy as np
        >>> input = Tensor(np.array([-1, 2, -3, 2, -1]), mindspore.float16)
        >>> output = ops.silu(input)
        >>> print(output)
        [-0.269  1.762  -0.1423  1.762  -0.269]
    """
    return silu_op(input)


def sin(input):
    r"""
    Computes sine of the input element-wise.

    .. math::

        output_i = \sin(input_i)

    Args:
        input (Tensor): The shape of tensor is
            :math:`(N,*)` where :math:`*` means, any number of additional dimensions.

    Returns:
        Tensor, has the same shape and dtype as the `input`. 
        The dtype of output is float32 when dtype of `input` is in
        [bool, int8, uint8, int16, int32, int64]. Otherwise output has the same dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.
        TypeError: On CPU or GPU: If dtype of `input` is not float16, float32 or float64, complex64, complex128.
                   On Ascend: If type of `input` is not bool, int8, uint8, int16, int32, int64, float16, float32 or float64, complex64, complex128.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.62, 0.28, 0.43, 0.62]), mindspore.float32)
        >>> output = ops.sin(input)
        >>> print(output)
        [0.5810352 0.27635565 0.41687083 0.5810352]
    """
    return sin_op(input)


def sinc(input):
    r"""
    Computes the normalized sinc of input.

    .. math::
        out_i = \begin{cases} \frac{sin(\pi input_i)}{\pi input_i} & input_i\neq 0\\ 
        1 & input_i=0 \end{cases}

    Args:
        input (Tensor): The input Tensor.

    Returns:
        Tensor, has the same shape as the `input`. The dtype of output is float32 when dtype of `input` is in
        [int, bool]. Otherwise output has the same dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.62, 0.28, 0.43, 0.62]), mindspore.float32)
        >>> output = ops.sinc(input)
        >>> print(output)
        [0.47735003 0.8759357  0.7224278  0.47735003]
    """
    return sinc_op(input)


def sinh(input):
    r"""
    Computes hyperbolic sine of the input element-wise.

    .. math::

        output_i = \sinh(input_i)

    Args:
        input (Tensor): The input tensor of hyperbolic sine function.

    Returns:
        Tensor, has the same shape as `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([0.62, 0.28, 0.43, 0.62]), mindspore.float32)
        >>> output = ops.sinh(input)
        >>> print(output)
        [0.6604918  0.28367308 0.44337422 0.6604918 ]
    """
    return sinh_op(input)


def softplus_ext(input, beta=1, threshold=20):
    r"""
    
    """
    return softplus_ext_op(input, beta, threshold)


def solve_triangular(a, b, trans=0, lower=False, unit_diagonal=False):
    r"""
    Solve the linear system :math:`a x = b` for `x`, Assuming `a` is a triangular matrix.

    Note:
        - `solve_triangular` is currently only used in `mindscience` scientific computing scenarios and
          dose not support other usage scenarios.
        - `solve_triangular` is not supported on Windows platform yet.

    Args:
        a (Tensor): A triangular matrix of shape :math:`(*, M, M)` where :math:`*` is zero or more batch dimensions.
        b (Tensor): A Tensor of shape :math:`(*, M)` or :math:`(*, M, N)`. Right-hand side matrix in :math:`a x = b`.
        trans (Union[int, str], optional): Type of system to solve. Default: ``0``.

            ========  =========
            trans     system
            ========  =========
            0 or 'N'  a x  = b
            1 or 'T'  a^T x = b
            2 or 'C'  a^H x = b
            ========  =========

        lower (bool, optional): Use only data contained in the lower triangle of `a`. Default: ``False``.
        unit_diagonal (bool, optional): If ``True``, diagonal elements of :math:`a` are assumed to be 1 and
            will not be referenced. Default: ``False``.

    Returns:
        Tensor of shape :math:`(*, M)` or :math:`(*, M, N)`,
        which is the solution to the system :math:`a x = b`.
        Shape of :math:`x` matches :math:`b`.

    Raises:
        ValueError: If `a` is less than 2 dimension.
        ValueError: if `a` is not square matrix.
        TypeError: If dtype of `a` and `b` are not the same.
        ValueError: If the shape of `a` and `b` are not matched.
        ValueError: If `trans` is not in set {0, 1, 2, 'N', 'T', 'C'}.

    Supported Platforms:
        ``Ascend`` ``CPU``

    Examples:
        >>> import numpy as onp
        >>> import mindspore
        >>> from mindspore import Tensor
        >>> from mindspore.ops import solve_triangular
        >>> a = Tensor(onp.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]], onp.float32))
        >>> b = Tensor(onp.array([3, 1, 3, 4], onp.float32))
        >>> x = solve_triangular(a, b, lower=True, unit_diagonal=False, trans='N')
        >>> print(x)
        [ 1. -1.  2.  2.]
        >>> print(a @ x)  # Check the result
        [3. 1. 3. 4.]
    """
    return solve_triangular_op(a, b, trans, lower, unit_diagonal)


def sort_ext(input, dim=-1, descending=False, stable=False):
    r"""
    
    """
    return sort_ext_op(input, dim, descending, stable)


def sqrt(x):
    r"""
    Returns sqrt of a tensor element-wise.

    .. math::

        out_{i} = \sqrt{x_{i}}

    Args:
        x (Tensor): The input tensor with a dtype of number.Number.

    Returns:
        Tensor, has the same shape as the `x`.

    Raises:
        TypeError: If `x` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([1.0, 4.0, 9.0]), mindspore.float32)
        >>> output = ops.sqrt(x)
        >>> print(output)
        [1. 2. 3.]
    """
    return sqrt_op(x)


def square(input):
    r"""
    Returns square of a tensor element-wise.

    .. math::

        y_i = input_i ^ 2

    Args:
        input (Tensor): The input tensor with a dtype of Number.

    Returns:
        Tensor, has the same shape and dtype as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1.0, 2.0, 3.0]), mindspore.float32)
        >>> output = ops.square(input)
        >>> print(output)
        [1. 4. 9.]
    """
    return square_op(input)


def stack_ext(tensors, dim=0):
    r"""
    Stacks a list of tensors in specified dim.

        Stacks the list of input tensors with the same rank `R`, output is a tensor of rank `(R+1)`.

        Given input tensors of shape :math:`(x_1, x_2, ..., x_R)`. Set the number of input tensors as `N`.
        If :math:`dim \ge 0`, the shape of the output tensor is
        :math:`(x_1, x_2, ..., x_{dim}, N, x_{dim+1}, ..., x_R)`.

        Args:
            tensors (Union[tuple, list]): A Tuple or list of Tensor objects with the same shape and type.
            dim (int): Dimension to stack. The range is [-(R+1), R+1). Default: ``0`` .

        Returns:
            Tensor. A stacked Tensor with the same type as `tensors`.

        Raises:
            TypeError: If the data types of elements in `tensors` are not the same.
            ValueError: If the length of `tensors` is not greater than zero;
                        or if dim is out of the range [-(R+1), R+1);
                        or if the shapes of elements in tensors are not the same.

        Supported Platforms:
            ``Ascend`` ``GPU`` ``CPU``

        Examples:
            >>> import mindspore
            >>> from mindspore import Tensor, mint
            >>> import numpy as np
            >>> data1 = Tensor(np.array([0, 1]).astype(np.float32))
            >>> data2 = Tensor(np.array([2, 3]).astype(np.float32))
            >>> output = mint.stack([data1, data2], 0)
            >>> print(output)
            [[0. 1.]
             [2. 3.]]
    """
    return stack_ext_impl(tensors, dim)


def strided_slice(input_x, begin, end, strides, begin_mask=0, end_mask=0, ellipsis_mask=0, new_axis_mask=0,
                  shrink_axis_mask=0):
    r"""
    Extracts a strided slice of a Tensor based on `begin/end` index and `strides`.

    This operation extracts a fragment of size (end-begin)/strides from the given 'input_tensor'.
    Starting from the beginning position, the fragment continues adding strides to the index until
    all dimensions are not less than the ending position.

    Note:
        - `begin` , `end` and `strides` must have the same shape.
        - `begin` , `end` and `strides` are all 1-D Tensor,  and their shape size
          must not greater than the dim of `input_x`.

    During the slicing process, the fragment (end-begin)/strides are extracted from each dimension.

    Example: For Tensor `input_x` with shape :math:`(5, 6, 7)`,
    set `begin`, `end` and `strides` to (1, 3, 2), (3, 5, 6),
    (1, 1, 2) respectively, then elements from index 1 to 3 are extrected for dim 0, index 3 to 5
    are extrected for dim 1 and index 2 to 6 with a `stirded` of 2 are extrected for dim 2, this
    process is equivalent to a pythonic slice `input_x[1:3, 3:5, 2:6:2]`.

    If the length of `begin`, `end` and `strides` is smaller than the dim of `input_x`,
    then all elements are extracted from the missing dims, it behaves like all the
    missing dims are filled with zeros, size of that missing dim and ones.

    Example: For Tensor `input_x` with shape :math:`(5, 6, 7)`,
    set `begin`, `end` and `strides` to (1, 3),
    (3, 5), (1, 1) respectively, then elements from index 1 to 3 are extrected
    for dim 0, index 3 to 5 are extrected for dim 1 and index 3 to 5 are extrected
    for dim 2, this process is equivalent to a pythonic slice `input_x[1:3, 3:5, 0:7]`.

    Here's how a mask works:
    For each specific mask, it will be converted to a binary representation internally, and then
    reverse the result to start the calculation. For Tensor `input_x` with
    shape :math:`(5, 6, 7)`. Given mask value of 3 which
    can be represented as 0b011. Reverse that we get 0b110, which implies the first and second dim of the
    original Tensor will be effected by this mask. See examples below, for simplicity all mask mentioned
    below are all in their reverted binary form:

    - `begin_mask` and `end_mask`

      If the ith bit of `begin_mask` is 1, `begin[i]` is ignored and the fullest
      possible range in that dimension is used instead. `end_mask` is analogous,
      except with the end range. For Tensor `input_x` with shape :math:`(5, 6, 7, 8)`, if `begin_mask`
      is 0b110, `end_mask` is 0b011, the slice `input_x[0:3, 0:6, 2:7:2]` is produced.

    - `ellipsis_mask`

      If the ith bit of `ellipsis_mask` is 1, as many unspecified dimensions as needed
      will be inserted between other dimensions. Only one non-zero bit is allowed
      in `ellipsis_mask`. For Tensor `input_x` with shape :math:`(5, 6, 7, 8)`,  `input_x[2:,...,:6]`
      is equivalent to `input_x[2:5,:,:,0:6]` ,  `input_x[2:,...]` is equivalent
      to `input_x[2:5,:,:,:]`.

    - `new_axis_mask`

      If the ith bit of `new_axis_mask` is 1, `begin`, `end` and `strides` are
      ignored and a new length 1 dimension is added at the specified position
      in the output Tensor. For Tensor `input_x` with shape :math:`(5, 6, 7)`, if `new_axis_mask`
      is 0b110,  a new dim is added to the second dim, which will produce
      a Tensor with shape :math:`(5, 1, 6, 7)`.

    - `shrink_axis_mask`

      If the ith bit of `shrink_axis_mask` is 1, `begin`, `end` and `strides`
      are ignored and dimension i will be shrunk to 0.
      For Tensor `input_x` with shape :math:`(5, 6, 7)`,
      if `shrink_axis_mask` is 0b010, it is equivalent to slice `x[:, 5, :]`
      and results in an output shape of :math:`(5, 7)`.

    Note:
        `new_axis_mask` and  `shrink_axis_mask` are not recommended to
        use at the same time, it might incur unexpected result.

    Args:
        input_x (Tensor): The input Tensor to be extracted from.
        begin (tuple[int]): A tuple which represents the location where to start.
        end (tuple[int]): A tuple or which represents the maximum location where to end.
        strides (tuple[int]): A tuple which represents the strides is continuously added
            before reaching the maximum location. Only int is allowed, it can be negative
            which results in reversed slicing.
        begin_mask (int, optional): Starting index of the slice. Default: ``0`` .
        end_mask (int, optional): Ending index of the slice. Default: ``0`` .
        ellipsis_mask (int, optional): An int mask, ignore slicing operation when set to 1. Default: ``0`` .
        new_axis_mask (int, optional): An int mask for adding new dims. Default: ``0`` .
        shrink_axis_mask (int, optional): An int mask for shrinking dims. Default: ``0`` .

    Returns:
        Tensor, return the extracts a strided slice of a Tensor based on `begin/end` index and `strides`.

    Raises:
        TypeError: If `begin_mask`, `end_mask`, `ellipsis_mask`, `new_axis_mask` or
            `shrink_axis_mask` is not an int.
        TypeError: If `begin`, `end` or `strides` is not tuple[int].
        ValueError: If `begin_mask`, `end_mask`, `ellipsis_mask`, `new_axis_mask` or
            `shrink_axis_mask` is less than 0.
        ValueError: If `begin`, `end` and `strides` have different shapes.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor, ops
        >>> input_x = Tensor([[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]],
        ...                   [[5, 5, 5], [6, 6, 6]]], mindspore.float32)
        >>> output = ops.strided_slice(input_x, (1, 0, 2), (3, 1, 3), (1, 1, 1))
        >>> # Take this " output = strided_slice(input_x, (1, 0, 2), (3, 1, 3), (1, 1, 1)) " as an example,
        >>> # start = [1, 0, 2] , end = [3, 1, 3], strides = [1, 1, 1], Find a segment of (start, end),
        >>> # note that end is an open interval
        >>> # To facilitate understanding, this operator can be divided into three steps:
        >>> # Step 1: Calculation of the first dimension:
        >>> # start = 1, end = 3, strides = 1, So can take 1st, 2nd rows, and then gets the final output at this time.
        >>> # output_1th =
        >>> # [
        >>> #     [
        >>> #         [3,3,3]
        >>> #         [4,4,4]
        >>> #     ]
        >>> #     [
        >>> #         [5,5,5]
        >>> #         [6,6,6]
        >>> #     ]
        >>> # ]
        >>> # Step 2: Calculation of the second dimension
        >>> # 2nd dimension, start = 0, end = 1, strides = 1. So only 0th rows
        >>> # can be taken, and the output at this time.
        >>> # output_2nd =
        >>> # [
        >>> #     [
        >>> #         [3,3,3]
        >>> #     ]
        >>> #     [
        >>> #         [5,5,5]
        >>> #     ]
        >>> # ]
        >>> # Step 3: Calculation of the third dimension
        >>> # 3nd dimension,start = 2, end = 3, strides = 1, So can take 2th cols,
        >>> # and you get the final output at this time.
        >>> # output_3ed =
        >>> # [
        >>> #     [
        >>> #         [3]
        >>> #     ]
        >>> #     [
        >>> #         [5]
        >>> #     ]
        >>> # ]
        >>> # The final output after finishing is:
        >>> print(output)
        [[[3.]]
        [[5.]]]
        >>> # another example like :
        >>> output = strided_slice(input_x, (1, 0, 0), (2, 1, 3), (1, 1, 1))
        >>> print(output)
        [[[3. 3. 3.]]]
    """
    strided_slice_op = _get_cache_prim(StridedSlice)(begin_mask, end_mask, ellipsis_mask, new_axis_mask,
                                                     shrink_axis_mask)
    return strided_slice_op(input_x, begin, end, strides)


def sub_ext(input, other, alpha=1):
    r"""
    Subtracts scaled other value from input Tensor.

    .. math::

        out_{i} = input_{i} - alpha \times other_{i}

    Note:
        - When the two inputs have different shapes,
          they must be able to broadcast to a common shape.
        - The two inputs and alpha comply with the implicit type conversion rules to make the data types
          consistent.

    Args:
        input (Union[Tensor, number.Number, bool]): The first input is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.
        other (Union[Tensor, number.Number, bool]): The second input, is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.
        alpha (number.Number): A scaling factor applied to `other`, default 1.

    Returns:
        Tensor, the shape is the same as the one of the input `input`, `other` after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs and alpha.

    Raises:
        TypeError: If the type of `input`, `other`, or `alpha` is not one of the following: Tensor, number.Number, bool.
        TypeError: If `alpha` is of type float but `input` and `other` are not of type float.
        TypeError: If `alpha` is of type bool but `input` and `other` are not of type bool.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> import mindspore
        >>> from mindspore import Tensor
        >>> from mindspore.ops.extend import sub
        >>> x = Tensor(np.array([4, 5, 6]).astype(np.float32))
        >>> y = Tensor(1, mindspore.int32)
        >>> alpha = 0.5
        >>> output = sub(x, y, alpha)
        >>> print(output)
        [3.5 4.5 5.5]
        >>> # the data type of x is float32, the data type of y is int32,
        >>> # alpha is a float, and the output is the data format of higher precision float32.
        >>> print(output.dtype)
        Float32
    """
    return sub_ext_op(input, other, alpha)


def sub(input, other):
    r"""
    Subtracts the second input tensor from the first input tensor element-wise.

    .. math::

        out_{i} = input_{i} - other_{i}

    Note:
        - When the two inputs have different shapes, they must be able to broadcast to a common shape.
        - The two inputs can not be bool type at the same time,
          [True, Tensor(True, bool\_), Tensor(np.array([True]), bool\_)] are all considered bool type.
        - The two inputs comply with the implicit type conversion rules to make the data types
          consistent.

    Args:
        input (Union[Tensor, number.Number, bool]): The first input is a number.Number or
            a bool or a tensor whose data type is
            `number <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_ or
            `bool_ <https://www.mindspore.cn/docs/en/master/api_python/mindspore.html#mindspore.dtype>`_.
        other (Union[Tensor, number.Number, bool]): The second input, when the first input is a Tensor,
            the second input should be a number.Number or bool value, or a Tensor whose data type is number or bool.

    Returns:
        Tensor, the shape is the same as the one after broadcasting,
        and the data type is the one with higher precision or higher digits among the two inputs.

    Raises:
        TypeError: If `input` and `other` are not number.Number or bool or Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1, 2, 3]), mindspore.int32)
        >>> other = Tensor(np.array([4, 5, 6]), mindspore.int32)
        >>> output = ops.sub(input, other)
        >>> print(output)
        [-3 -3 -3]
    """
    return sub_op(input, other)


def tanh(input):
    r"""
    Computes hyperbolic tangent of input element-wise. The Tanh function is defined as:

    .. math::

        tanh(x_i) = \frac{\exp(x_i) - \exp(-x_i)}{\exp(x_i) + \exp(-x_i)} = \frac{\exp(2x_i) - 1}{\exp(2x_i) + 1},

    where :math:`x_i` is an element of the input Tensor.

    Tanh Activation Function Graph:

    .. image:: ../images/Tanh.png
        :align: center

    Args:
        input (Tensor): Input of Tanh.

    Returns:
        Tensor, with the same type and shape as the `input`.

    Raises:
        TypeError: If `input` is not a Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU``  ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([1, 2, 3, 4, 5]), mindspore.float32)
        >>> output = ops.tanh(input)
        >>> print(output)
        [0.7615941 0.9640276 0.9950547 0.9993293 0.9999092]
    """
    return tanh_op(input)


def topk_ext(input, k, dim=-1, largest=True, sorted=True):
    r"""
    
    """
    return topk_ext_op(input, k, dim, largest, sorted)


def trace(input):
    r"""
    Returns a new tensor that is the sum of the `input` main trace.

    Note:
        Input must be matrix, and complex number is not supported at present.

    Args:
        input (Tensor): A matrix to be calculated. The matrix must be two dimensional.

    Returns:
        Tensor, with the same data type as input `input`, and size equals to 1.

    Raises:
        TypeError: If `input` is not a Tensor.
        ValueError: If the dimension of `input` is not equal to 2.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([[10, 11, 12], [13, 14, 15], [16, 17, 18]]), mindspore.float32)
        >>> output = ops.trace(input)
        >>> print(output)
        42.0
        >>> input = Tensor(np.arange(1, 13).reshape(3, 4), mindspore.float32)
        >>> output = ops.trace(input)
        >>> print(output)
        18.0
        >>> input = Tensor(np.arange(12, 0, -1).reshape(4, 3), mindspore.float32)
        >>> output = ops.trace(input)
        >>> print(output)
        24.0
    """
    return trace_op(input)


def transpose(input, input_perm):
    r"""
    Permutes the dimensions of the input tensor according to input permutation.

    For a 1-D array this has no effect, as a transposed vector is simply the same vector.
    To convert a 1-D array into a 2D column vector please refer to :func:`mindspore.ops.expand_dims`.
    For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given,
    their order indicates how the axes are permuted (see Examples).
    If axes are not provided and a.shape is :math:`(i[0], i[1], ... i[n-2], i[n-1])`,
    then a.transpose().shape is :math:`(i[n-1], i[n-2], ... i[1], i[0])`.

    Note:
        On GPU and CPU, if the value of `input_perm` is negative, its actual value is `input_perm[i] + rank(input)`.
        Negative value of `input_perm` is not supported on Ascend.

    Args:
        input (Tensor): The shape of tensor is :math:`(x_1, x_2, ..., x_R)`.
        input_perm (tuple[int]): The permutation to be converted. The elements in `input_perm` are composed of
            the indexes of each dimension of `input`. The length of `input_perm` and the shape of `input` must be
            the same. Only constant value is allowed. Must be in the range [-rank(input), rank(input)).

    Returns:
        Tensor, the type of output tensor is the same as `input` and the shape of output tensor is decided by the
        shape of `input` and the value of `input_perm`.

    Raises:
        TypeError: If `input_perm` is not a tuple.
        ValueError: If length of shape of `input` is not equal to length of shape of `input_perm`.
        ValueError: If the same element exists in `input_perm`.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> input = Tensor(np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]), mindspore.float32)
        >>> input_perm = (0, 2, 1)
        >>> output = ops.transpose(input, input_perm)
        >>> print(output)
        [[[ 1.  4.]
          [ 2.  5.]
          [ 3.  6.]]
         [[ 7. 10.]
          [ 8. 11.]
          [ 9. 12.]]]
    """
    return transpose_op(input, input_perm)


def tril(input, diagonal=0):
    r"""
    Returns the lower triangle part of 'input' (elements that contain the diagonal and below),
    and set the other elements to zeros.

    Args:
        input (Tensor): A Tensor with shape :math:`(x_1, x_2, ..., x_R)`. The rank must be at least 2.
          Supporting all number types including bool.
        diagonal (int, optional): An optional attribute indicates the diagonal to consider, default: 0,
            indicating the main diagonal.

    Returns:
        Tensor, the same shape and data type as the input `x`.

    Raises:
        TypeError: If `x` is not a Tensor.
        TypeError: If `diagonal` is not an int.
        TypeError: If the type of `x` is neither number nor bool.
        ValueError: If the rank of `x` is less than 2.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[ 1,  2,  3,  4],
        ...                      [ 5,  6,  7,  8],
        ...                      [10, 11, 12, 13],
        ...                      [14, 15, 16, 17]]))
        >>> result = ops.tril(x)
        >>> print(result)
        [[ 1  0  0  0]
         [ 5  6  0  0]
         [10 11 12  0]
         [14 15 16 17]]
        >>> x = Tensor(np.array([[ 1,  2,  3,  4],
        ...                      [ 5,  6,  7,  8],
        ...                      [10, 11, 12, 13],
        ...                      [14, 15, 16, 17]]))
        >>> result = ops.tril(x, diagonal=1)
        >>> print(result)
        [[ 1  2  0  0]
         [ 5  6  7  0]
         [10 11 12 13]
         [14 15 16 17]]
        >>> x = Tensor(np.array([[ 1,  2,  3,  4],
        ...                      [ 5,  6,  7,  8],
        ...                      [10, 11, 12, 13],
        ...                      [14, 15, 16, 17]]))
        >>> result = ops.tril(x, diagonal=-1)
        >>> print(result)
        [[ 0  0  0  0]
         [ 5  0  0  0]
         [10 11  0  0]
         [14 15 16  0]]
    """
    return tril_impl(input, diagonal)


def triu(input, diagonal=0):
    r"""
    Returns the upper triangle part of 'input' (elements that contain the diagonal and below),
    and set the other elements to zeros.

    .. warning::
        This is an experimental API that is subject to change or deletion.

    Args:
        input (Tensor): The input tensor with shape :math:`(M, N, *)` where * means any number of additional dimensions.
        diagonal (int, optional): An optional attribute indicates the diagonal to consider, default: ``0``,
            indicating the main diagonal.

    Returns:
        Tensor, a tensor has the same shape and data type as input.

    Raises:
        TypeError: If `diagonal` is not an int.
        TypeError: If `input` is not a Tensor.
        ValueError: If the dimension of `input` is less than 2.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import numpy as np
        >>> from mindspore import Tensor, ops
        >>> x = Tensor(np.array([[ 1,  2,  3,  4],
        ...                      [ 5,  6,  7,  8],
        ...                      [10, 11, 12, 13],
        ...                      [14, 15, 16, 17]]))
        >>> result = ops.triu(x)
        >>> print(result)
        [[ 1  2  3  4]
         [ 0  6  7  8]
         [ 0  0 12 13]
         [ 0  0  0 17]]
        >>> x = Tensor(np.array([[ 1,  2,  3,  4],
        ...                      [ 5,  6,  7,  8],
        ...                      [10, 11, 12, 13],
        ...                      [14, 15, 16, 17]]))
        >>> result = ops.triu(x, diagonal=1)
        >>> print(result)
        [[ 0  2  3  4]
         [ 0  0  7  8]
         [ 0  0  0 13]
         [ 0  0  0  0]]
        >>> x = Tensor(np.array([[ 1,  2,  3,  4],
        ...                      [ 5,  6,  7,  8],
        ...                      [10, 11, 12, 13],
        ...                      [14, 15, 16, 17]]))
        >>> result = ops.triu(x, diagonal=-1)
        >>> print(result)
        [[ 1  2  3  4]
         [ 5  6  7  8]
         [ 0 11 12 13]
         [ 0  0 16 17]]
    """
    return triu_impl(input, diagonal)


def tuple_to_tensor(input_tuple, dtype=None):
    r"""
    
    """
    return tuple_to_tensor_op(input_tuple, dtype)


def unsorted_segment_sum(input_x, segment_ids, num_segments):
    r"""
    Computes the sum of a tensor along segments.

    Calculates a tensor such that :math:`\text{output}[i] = \sum_{segment\_ids[j] == i} \text{data}[j, \ldots]`, where
    :math:`j,...` is a tuple describing the index of element in data.
    `segment_ids` selects which elements in data to sum
    up. Segment_ids does not need to be sorted, and it does not need to cover all values in the entire valid value
    range.

    The following figure shows the calculation process of unsorted_segment_sum:

    .. image:: UnsortedSegmentSum.png

    Note:
        - If the segment_id i is absent in the segment_ids, then output[i] will be filled with 0.
        - On Ascend, if the value of segment_id is less than 0 or greater than the length of the input data shape, an
          execution error will occur.

    If the sum of the given segment_ids :math:`i` is empty, then :math:`\text{output}[i] = 0`. If the given segment_ids
    is negative, the value will be ignored. 'num_segments' must be equal to the number of different segment_ids.

    Args:
        input_x (Tensor): Input Tensor contains the data to be summed.
            The shape is :math:`(x_1, x_2, ..., x_R)`.
        segment_ids (Tensor): The label indicates the segment to which each element belongs.
            Set the shape as :math:`(x_1, x_2, ..., x_N)`, where 0 < N <= R.
        num_segments (Union[int, Tensor], optional): Set :math:`z` as num_segments, it can be an int or 0-D Tensor.

    Returns:
        Tensor, the shape is :math:`(z, x_{N+1}, ..., x_R)`.

    Raises:
        TypeError: If `num_segments` is not an int or 0-D Tensor.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import Tensor
        >>> from mindspore import ops
        >>> input_x = Tensor([1, 2, 3, 4], mindspore.float32)
        >>> segment_ids = Tensor([0, 0, 1, 2], mindspore.int32)
        >>> num_segments = 4
        >>> output = ops.unsorted_segment_sum(input_x, segment_ids, num_segments)
        >>> print(output)
        [3. 3. 4. 0.]
        >>> input_x = Tensor([1, 2, 3, 4, 2, 5], mindspore.float32)
        >>> segment_ids = Tensor([0, 0, 1, 2, 3, 4], mindspore.int32)
        >>> num_segments = 6
        >>> output = ops.unsorted_segment_sum(input_x, segment_ids, num_segments)
        >>> print(output)
        [3. 3. 4. 2. 5. 0.]
    """
    return unsorted_segment_sum_op(input_x, segment_ids, num_segments)


def view(input, shape):
    r"""
    Reshape the tensor according to the input shape. It's the same as :func:`mindspore.Tensor.reshape`,
    implemented by the underlying reshape operator.

    Args:
        shape (Union[tuple(int), int]): Dimension of the output tensor.

    Returns:
        Tensor, which dimension is the input shape's value.

    Examples:
        >>> from mindspore import Tensor
        >>> import numpy as np
        >>> a = Tensor(np.array([[1, 2, 3], [2, 3, 4]], dtype=np.float32))
        >>> output = a.view((3, 2))
        >>> print(output)
        [[1. 2.]
        [3. 2.]
        [3. 4.]]
    """
    return view_op(input, shape)


def weight_quant_batch_matmul(x, weight, antiquant_scale, antiquant_offset=None, quant_scale=None, quant_offset=None,
                              bias=None, transpose_x=False, transpose_weight=False, antiquant_group_size=0):
    r"""
    
    """
    weight_quant_batch_matmul_op = _get_cache_prim(WeightQuantBatchMatmul)(transpose_x, transpose_weight,
                                                                           antiquant_group_size)
    return weight_quant_batch_matmul_op(x, weight, antiquant_scale, antiquant_offset, quant_scale, quant_offset, bias)


zeros_op = Zeros()


def zeros(size, dtype=None):
    r"""
    Creates a tensor filled with 0 with shape described by `size` and fills it with value 0 in type of `dtype`.

    .. warning::
        For argument `size`, Tensor type input will be deprecated in the future version.

    Args:
        size (Union[tuple[int], list[int], int, Tensor]): The specified shape of output tensor. Only positive integer or
            tuple or Tensor containing positive integers are allowed. If it is a Tensor,
            it must be a 0-D or 1-D Tensor with int32 or int64 dtypes.
        dtype (:class:`mindspore.dtype`, optional): The specified type of output tensor. If `dtype` is ``None`` ,
            mindspore.float32 will be used. Default: ``None`` .

    Returns:
        Tensor, whose dtype and size are defined by input.

    Raises:
        TypeError: If `size` is neither an int nor an tuple/list/Tensor of int.

    Supported Platforms:
        ``Ascend`` ``GPU`` ``CPU``

    Examples:
        >>> import mindspore
        >>> from mindspore import ops
        >>> output = ops.zeros((2, 2), mindspore.float32)
        >>> print(output)
        [[0. 0.]
         [0. 0.]]
    """
    return zeros_op(size, dtype)
